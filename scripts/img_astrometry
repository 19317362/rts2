#!/usr/bin/perl -w
#
# (C) 2010, Markus Wildi, markus.wildi@one-arcsec.org
#
#   img_astrometry
#   usage: img_atrometry /path/to/file.fits
#
#   It is usually called by rts2-executor to perform the astrometric
#   calibration of the just acquired image. rts2-executor feeds the
#   corrections to the rts2-teld-* telescope dirver.
# 
#   Configuration:
my $scale_at_binning_1= 1.41 ;   # scale in [arcsec/pixel]
my $scale_relative_error= 0.05 ; # the scale used by solve-field
#                                  is allowed to vary by this quantity
my $down_sample= 2 ; # astrometry as somtimes problems, seit to 1 for
#                      moderate sized CCD chips
#
#   This script calls solve-filed see http://astrometry.net/
#   and returns 
#   $img_id, $crval1, $crval2, $crval1-$oira, $crval2-$oirdec
#   as e.g.
#   1 131.254623 18.904446 (1.162623,-0.767654)
#
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#   Or visit http://www.gnu.org/licenses/gpl.html.
#

use strict;
use Getopt::Long qw(:config no_ignore_case) ;
#
use constant TRUE_STR                   => "TRUE" ;
use constant FALSE_STR                  => "FALSE" ;
use constant TRUE_VAL                   => 1 ;
use constant FALSE_VAL                  => -1 ;

my $fits_file= $ARGV[0] ;
my @fits_file_name_parts= split( /\.fits$/, $fits_file) ;
my $scale ;
my $img_id ;

if(  $ARGV[0]=~ /.+/) {
    `logger img_process  $ARGV[0]`;
} else {
    `logger img_process no arguments $ARGV[0], $ARGV[1]` ;
    print "img_process no arguments received" ;
    exit(1) ;
}
# Files to be deleted at the end (and at the beginning)
# remove these
#test.fits
#test.axy
#test-objs.png
#test.wcs
#test.solved
#test.rdls
#test.new
#test.match
#test-indx.xyls
#test.corr
#test-indx.png
#test-ngc.png
my @extensions=(
".axy",
"-objs.png",
".wcs",
".solved",
".rdls",
".new",
".match",
"-indx.xyls",
".corr",
"-indx.png",
"-ngc.png",
    ) ;
foreach my $extension( @extensions) {
    `rm $fits_file_name_parts[0]$extension >/dev/null 2>&1` ;
}
#
# get 
# @IMGID
# @BINNING and calculate the image scale from the original fits file
# 
open(RTS2IMAGE, "rts2-image -p \'\@IMGID \@BINNING \@OBJECT\' $fits_file 2>/dev/null|") or die "get_fits_files: can't start rts2-image: $!";
my $missing= FALSE_VAL ;
while(my $line= <RTS2IMAGE>){
# parse output
# U 6121 2x2 2048 2048 0. 0.
# or
# @FILTER 1500 2x2 1 1 0. 0.
# in case the keyword is not present
    if( $line=~ m/@/) {

# Check if fits key word OBJECT exists
#
	if( $line=~ m/OBJECT/) {
	    # print "img_process inserting OBJECT\n";
	    # FAKE `fitsheader -w OBJECT=\"GRB 091202.965 by img_process\" $fits_file` ;
	} else {
	    $missing= TRUE_VAL ;
	    #print "img_process: in file $fits_file fits keyword missing: $line\n" ;
	    last ;
	}
    }
    #print "img_process OBJECT OBJECT OBJECT OBJECT OBJECT\n" ;
    my @items= split(/[ ]+/, $line) ;

    $img_id   =$items[0] ;

    if( $items[1]=~ m/1x1/) {
	$scale= 1. * $scale_at_binning_1 ;
    } elsif( $items[1]=~ m/2x2/) {
	$scale= 2. * $scale_at_binning_1 ;
    } else {
	$missing= TRUE_VAL ;
	print "img_process DO not understand binning \n" ;
    }
}
if( $missing== TRUE_VAL) {
    print "img_process:$fits_file,  missing fits header key words \@IMGID, \@OBJECT and/or \@BINNING\n" ;
    exit ;
}
# solve-field
#

my $scale_low=  $scale - $scale_relative_error * $scale ;   
my $scale_high= $scale + $scale_relative_error * $scale ;
`logger img_process  $fits_file begin solve-field`;
open( SOLVEFIELD, "/usr/local/astrometry/bin/solve-field --downsample $down_sample --no-plots --no-fits2fits --no-verify  --scale-units arcsecperpix --scale-low $scale_low --scale-high $scale_high $fits_file >/dev/null 2>&1 |") or die "img_process: can't start solve-field: $!";
while(my $line= <SOLVEFIELD>){
##### if debug is required   print $line ;
}
close ( SOLVEFIELD) ;
`logger img_process  end solve-field`;
# read the results from, solve-field created file *.new
#
my $fits_file_new= $fits_file_name_parts[0] . ".new" ;

my $crval1 ;
my $crval2 ;
my $oira ;
my $oirdec ;
# ori open(RTS2IMAGE, "rts2-image -p \'\@CRVAL1 \@CRVAL2 \@ORIRA \@ORIDEC\' $fits_file_new 2>/dev/null|") or die "get_fits_files: can't start rts2-image: $!";
open(RTS2IMAGE, "rts2-image -p \'\@CRVAL1 \@CRVAL2 \@ORIRA \@ORIDEC\' $fits_file_new |") or die "get_fits_files: can't start rts2-image: $!";

$missing= FALSE_VAL ;
while(my $line= <RTS2IMAGE>){
# parse output
    `logger RTS2IMAGE imhead return values $line` ;
    if( $line=~ m/@/) {
	$missing= TRUE_VAL ;
	#print "img_process: in file $fits_file fits keyword missing: $line\n" ;
	last ;
    }
    my @items= split(/[ ]+/, $line) ;

    $crval1   =$items[0] ;
    $crval2   =$items[1] ;
    $oira     =$items[2] ;
    $oirdec   =$items[3] ;
}
if( $missing== TRUE_VAL)
{
    print "img_process: $fits_file, $fits_file_new, missing fits header key words \@CRVAL1 \@CRVAL2 \@ORIRA \@ORIDEC \n" ;
    `logger img_process  $fits_file no astrometric calibration`;

} else {

    printf( "%d %f %f (%f,%f)\n",$img_id, $crval1, $crval2, $crval1- $oira,$crval2-$oirdec);
    `logger img_process  $fits_file successful astrometric calibration`;
}
foreach my $extension( @extensions) {
    `rm $fits_file_name_parts[0]$extension >/dev/null 2>&1` ;
}
