Prerequisites
=============
 python3(.5)
 # Ubuntu 16.04:
 apt install  python3-watchdog
     	      python3-requests
	      python3-pandas  
              yale # bright star catalog
	           # http://tdc-www.harvard.edu/catalogs/bsc5.html
	      libnova-dev
	      telnet
	      saods9
	      
 pip3 install astropy (1.2.1 or newer)
              numpy
	      scipy
	      matplotlib
              pyds9
	      pyfits
	      
 libnova needs to be on LD_PATH as libnova.so

 Do a:
 wget http://maia.usno.navy.mil/ser7/finals2000A.all  

Use case
========
u_point's use cases are:

- unattended data acquisition and analysis done
  with astrometry.net. In this case do not use
  data from SExtractor (stored in file
  u_point_positions_sxtr.anl, see u_point.py).

- a CCD FoV which is too small for astrometry.net
  or similar to work reliably.
  As targets serve "lonely" objects from Yale's
  Bright Star Catalog which can be identified by a
  human being by looking at the CCD image.

Very quick tour: do_it_all_dss.sh, do_it_all_rts2.sh
====================================================
Script do_it_all_dss.sh needs no running installation
of RTS2 and after the above mentioned packages have
been installed, it is ready to use.

 cd $HOME/rts2/scripts
 ./do_it_all_dss.sh

This script performs all necessary steps to get
a pointing model fit. Steps:

1) selecting objects from Yale Bright Star Catalog
visible at observatory's latitude.

2) creating a grid of nominal AltAz positions

3) acquiring for grid positions an image from DSS

4) analyzing the obtained images with SExtractor
(optionally with astrometry.net).

5) performing the fit of the catalog and mount
positions, finally plot the results.

The script provides additional information and
comments about how to use these scripts.

do_it_all_dss.sh fetches images from DSS if
option --fetch-dss-image is specified and the
mount device is purely software (see devices.py).

do_it_all_rts2.sh behaves identically but it
uses a running RTS2 instance either with real
or dummy devices. To run this script with
dummy devices remove in /etc/rts2/devices all
but

  camd    dummy   C0      --width 862 --height 655 --frame-transfer --localhost localhost
  teld    dummy   T0      --move fast --localhost localhost
  # optionally let T0 run at 2deg/sec:
  #teld    dummy   T0      --localhost localhost

and start do_it_all_rts2.sh. It performs the
same steps like do_it_all_rts2.sh. Being able
to communicate with RTS2 the scripts are started
differently:

 acq_script="$HOME/rts2/scripts/u_point/u_acquire_fetch_dss_continuous.sh"
 rts2-scriptexec -d C0 -s " exe $acq_script "

where u_acquire_fetch_dss_continuous.sh is
a (bash) script executing the real script.
The same thing if a progress plot is displayed:

 plt_script="$HOME/rts2/scripts/u_point/u_acquire_plot.sh"
 rts2-scriptexec -d C0 -s " exe $plt_script" 

Status u_point as of 2016-11-23
===============================
I just completed the first release. Missing are:

- proper documentation
- EQ mount analysis
- Python unit tests

Please feel free to contact me (wildi.markus@bluewin.ch)

Status u_point.py as of 2016-11-23
==================================
I started with astropy and found that there are
differences e.g. between EQ (CIRS) to AltAz
transformations I could not explain nor did
someone on astropy@scipy.org answer.

I developed u_point.py based on libnova and added
later the astropy code for comparison again. There
are still differences and I'd be glad if someone
can point me into the right direction.

The EQ models are not usable yet.

The AltAz model does not always converge. Repeat
the fitting several times to gain confidence. I
observed that fits on simulated data do not
converge. In such cases repeat the data generation.

Status u_acquire.py as of 2016-11-23
====================================
I dry tested u_acquire.py in simulation mode and
together with RTS2 dummy devices. I do not expect
any major failures if a real AltAz mount is used.

u_acquire.py is suitable for AltAz mounts but
soon EQ mounts can be used too.

Common features
===============
All scripts read and write best to common
subdirectory. Set --base-path for all scripts
identically and do not change the defaults of
the file names.

The log files are written to /tmp/<script_name>.log
Logging to console is enabled with --toconsole. If
specidfied the level is set to DEBUG. Default is
INFO which means the scripts are almost silent.
If in trouble enable --toconsole.

Scripts u_acqurie.py and u_analyze.py can be
interrupted and resumed at any time, or while
u_acquire.py is still running, u_analyze.py
can be started several times, using the time.

If options --plot and --animate are specified
u_acqurie.py and u_analyze.py show an updated
plot e.g. where the mount actually points to
or which position is analyzed. If --ds9-display
is specified the the FITS images will be displayed
through DS9. u_point.py behaves in the same
way but has no progress report.


Preparation: u_select.py, u_acquire.py
======================================
This step is required in case one can not
use astrometry.net. From SExtractor's list
only the brightest star is retrieved and that
is what Yale Bright Star Catalog provides.

Script u_select.py  filters objects which are
visible at a given latitude

 u_select.py --obs-latitude m75.1 --plot

and writes it to a file. The default can be
replaced with option --observable-catalog.
For further options use u_select.py --help.

The grid of nominal AltAz positions to be observed
is created by

 u_acquire.py --create-nominal --plot

and the result is written to nominal_positions.nml
if not specified differently. Check the plot and if
not satisfied see options --altitude-interval,
--azimuth-interval, --az-step and --alt-step for
further refinements.

Meteo data
==========
Often meteo data are acquired from a separate
system. Either provided by RTS2 or an external
source. See classes Meteo() in meteo.py (dummy)
or e.g. meteo_dome_c.py for a real implementation.

As default Meteo() from meteo.py is used if
not specified with --meteo-class.

Data acquisition: u_acquire.py
==============================
The data acquisition can be interrupted and resumed
at any time.

Two modes of operations exist:

1) non continuous mode (default)
2) continuous mode (--mode-continues)

If operated in continuous mode, no user interaction
is required.
To watch the mount acquiring data, in case of
--device-class DeviceDss (default), use

./u_acquire.py --base-path $BASE_PATH --plot \
  --ds9-display --animate  --level DEBUG --toc

with option --device-class DeviceRts2 (adapt
u_acquire_plot.sh to your needs)

 plt_script="$HOME/rts2/scripts/u_point/u_acquire_plot.sh"
 rts2-scriptexec -d C0 -s " exe $plt_script" 

If operated in non continuous mode, user interaction
is required and done via telnet 127.0.0.1 usually on
port 9999 (see /tmp/u_acquire.log for the actual
setting). Allowed commands are setting a different
exposure time or redo a given nominal position ev.
with a different exposure time.

The mount is operated through, e.g. DeviceRts2 (see
devices.py). The 'ORI' (see rts2-mon, T0) coordinates
are set by u_acquire.py. Once u_acquire.py waits for
user input, the mount can be commanded using 'OFFS'
(see rts2-mon, T0) to center the object on the CCD.

If the CCD can not be driven by RTS2 or it is not
suitable, a watch dog can be set to monitor the
directory where the FITS images are written, see
options

   --mode-watchdog
   --watchdog-directory

The final output of u_acquire.py is a book keeping
file, usually named acquired_positions.acq (see
option --acquired-position) where all necessary
information is stored.

u_acquire.py does not analyze the images.

Image analysis: u_analyze.py
============================
Once the acquisition run is completed the analysis
is done with u_analyze.py preparing the input for
u_point.py.

u_analyze.py writes RA/Dec coordinates of the
brightest star and the field center, obtained by
astrometry.net, to a second set of files, usually
named:

 analyzed_positions.anl
 u_point_positions_sxtr.anl
 u_point_positions_astr.anl

In case the analysis was interrupted, analyzed
positions are read back from analyzed_positions.anl
and dropped.
Only the remaining positions in acquired_positions.acq
are considered and appended to analyzed_positions.anl
The files u_point_positions*.anl provide the data of
SExtractor (sxtr) and astrometry.net (astr) separately
and can be read in by u_point.py.

If process u_acquire.py is still in progress, you may
analyze the already acquired data (speeding up the
whole process). 


Pointing model: u_point.py
==========================
The files

 u_point_positions_sxtr.anl
 u_point_positions_astr.anl

prepared in the previous step can be fed into

 ./u_point.py --base-path $BASE_DIRECTORY \
    --mount-data  u_point_positions_sxtr.anl --plot 
 ./u_point.py --base-path $BASE_DIRECTORY \
    --mount-data  u_point_positions_astr.anl --plot 

and the plots will show the result of the fitted
parameters as well as the raw data.

Plots labled A2 and K (title upper left) provide
a call back function. If a data point is clicked,
it is annotated on all other plots. This feature
is still in it's infancy.

Walk through with RTS2 dummy devices
====================================

The following description walks you through a simulated
data acquisition with DSS image retrieval for an easy
comparison with the "real" sky.

Configure RTS2 with dummy devices (/etc/rts2/devices):

 #RTS2 devices configuration
 #device type    device_name     options
 camd    dummy   C0      --width 862 --height 655 --frame-transfer --localhost localhost
 teld    dummy   T0      --move fast --localhost localhost
 
u_point is not yet installed on the system's PYTHON path.

 cd $HOME/rts2/scripts/u_point
 
Create the site specific observable star catalog based on
Yale Bright Star catalog, see help for e.g. observatory
specific options

 ./u_select.py --plot --brightness-interval "6.0 7.0" --minimum-separation 1.5
 ls -l observable.cat
 -rw-rw-r-- 1 wildi wildi 108813 Nov  6 10:38 observable.cat

Start simulated data acquisition:

 sudo bash
 systemctl start rts2 # Ubuntu 16.04, see $HOME/rts2/conf/rts2.service
 rts2-scriptexec -d C0 -s " exe ./u_acquire_fetch_dss_continuous.sh "

In a separate terminal:

 tail -f /tmp/u_acquire.log 

or at any time for a progress report plot (check option
--base-path)

 ./u_acquire.py --plot --animate --ds9-display

Red dots are remaining nominal and blue dots are acquired positions
To see DSS catalog FITS images, click on a blue point.

Recommended terminal set up
---------------------------

For each listed command open a terminal which can be
viewed "in parallel":

 tail -f /tmp/u_acquire.log 
 telnet 127.0.0.1 9999
 ./u_acquire.py --plot;ds9 -zscale dss*fits
 rts2-scriptexec -d C0 -s " exe ./u_acquire_fetch_dss_continuous.s "
 

Pointing model analysis: u_point.py
===================================

Fetch real data and fit them

 cd ~/rts2/scripts/u_point/
 wget http://azug.minpet.unibas.ch/~wildi/mount_data_meteo.txt
 ./u_point.py --toc  --mount-data mount_data_meteo.txt --plot

the output should be similar to:

 --------------------------------------------------------
 fitted values:
 C1: horizontal telescope collimation: -339.9976 [arcsec]
 C2: constant azimuth offset         :+1024.7588 [arcsec]
 C3: tipping-mount collimation       :   +3.1370 [arcsec]
 C4: azimuth axis tilt West          : +719.9432 [arcsec]
 C5: azimuth axis tilt North         : +422.3190 [arcsec]
 C6: vertical telescope collimation  : +579.9046 [arcsec]
 C7: gravitational tube bending      :  -85.1722 [arcsec]
 /home/wildi/sw/python/v_point/lib/python3.5/site-packages/scipy/optimize/minpack.py:427: RuntimeWarning: Number of calls to function has reached maxfev = 800.
  warnings.warn(errors[info][0], RuntimeWarning)
  fit projection not converged, status: 5

and the plots appear. Ignore the warning since it is related
to a Gaussian fit. Then do a simulation

  ./u_simulate.py --sigma 0. --aa "-339.99 1024.75 3.13  719.9 422.31 579.9 -85.17" --mount-data test.dat  --step 12
  
and the output should be similar to:

 input parameters
 C1: horizontal telescope collimation: -339.9900 [arcsec]
 C2: constant azimuth offset         :+1024.7500 [arcsec]
 C3: tipping-mount collimation       :   +3.1300 [arcsec]
 C4: azimuth axis tilt West          : +719.9000 [arcsec]
 C5: azimuth axis tilt North         : +422.3100 [arcsec]
 C6: vertical telescope collimation  : +579.9000 [arcsec]
 C7: gravitational tube bending      :  -85.1700 [arcsec]
 end input parameters

and finally fit the simulated data with

 ./u_point.py --toc  --mount-data test.dat

and the output shows the parameters in good agreement

 --------------------------------------------------------
 fitted values:
 C1: horizontal telescope collimation: -339.9803 [arcsec]
 C2: constant azimuth offset         :+1031.2422 [arcsec]
 C3: tipping-mount collimation       :   +3.1193 [arcsec]
 C4: azimuth axis tilt West          : +718.4110 [arcsec]
 C5: azimuth axis tilt North         : +422.1173 [arcsec]
 C6: vertical telescope collimation  : +579.8966 [arcsec]
 C7: gravitational tube bending      :  -85.1844 [arcsec]
 /home/wildi/sw/python/v_point/lib/python3.5/site-packages/scipy/optimize/minpack.py:427: RuntimeWarning: Number of calls to function has reached maxfev = 800.
  warnings.warn(errors[info][0], RuntimeWarning)
  fit projection not converged, status: 5

And the simulated plots are as "ugly" as the data.


Main differences to Petr's gpoint
---------------------------------

u_point includes meteo data and has Python
bindings for libnova.so, as far as I used it.

Interestingly the AltAz model fits well without
meteo data since the tube droop parameter is
a function of Alt too. But as temperature varies
the model will fail to correct the position.

Adding a different model, e.g. J. Condon (1992)
suggested to use a Fourier transformed function,
can be done easily on the source level, at
least that's my hope.

Defining a model
================
Not sastisfied with the existing models:

 model_buie.py
 model_u_point.py
 model_altaz.py

create your own. Create class Moldel(ModelBase) and
implement three methods (see e.g. model_altaz.py):

  def d_lon(self,cat_lons,cat_lats,d_lons):
  def d_lat(self,cat_lons,cat_lats,d_lats):
  def fit_model(self,cats=None,mnts=None,selected=None,**kwargs):

where cat_* are apparent and d_* are the differences
between cat_* - mnt_*, where mnt_* are the coordinates
read at the setting circles of the mount. If method fit_model()
is implemented for a EQ style fit (see model_u_point.py), 
observatory's latitude has to be passed:

  def fit_model(self,cats=None,mnts=None,selected=None,**kwargs):
    if kwargs is None:
      self.lg.error('expected key word: obs, exiting'.format(name, value))
      sys.exit(1)

    for name, value in kwargs.items():
      if 'obs' in name:
        self.phi=value.latitude.radian
        break
      else:
        self.lg.error('got unexpected key word: {0}={1}, exiting'.format(name, value))
        sys.exit(1)


Format of the coordinates file and units
========================================
The data formats of the various files and objects
are best described in structures.py.

Mount coordinates are the apparent coordinates as read
at the setting circles, while catalog coordinates are
J2000 (ICRS).
Exposure, temperature, pressure and humidity are optional
as input to u_point.py. QFE is the pressure at the
observatory (not sea level).

