Prerequisites
=============

 python3(.5)
 # Ubuntu 16.04:
 apt install  python3-watchdog
     	      python3-requests
	      python3-pandas  
              yale # bright star catalog
	           # http://tdc-www.harvard.edu/catalogs/bsc5.html
	      libnova-dev
	      telnet
	      saods9
	      
 pip3 install astropy (1.2.1 or newer)
              numpy
	      scipy
	      matplotlib
              pyds9
	      pyfits
	      
 libnova (needs to be on LD_PATH as libnova.so)

Very quick tour: do_it_all.sh
=============================

Script do_it_all*.sh needs no running installation
of RTS2 and after the above mentioned packages have
been installed, it is ready to use.

cd $HOME/rts2/scripts

./do_it_all_astropy.sh # use this 
./do_it_all_libnova.sh

2016-11-15: on going discussion about precision
astro.py/libnova.

This script performs all necessary steps to get
a pointing model fit. Steps:

1) selecting objects from Yale Bright Star Catalog
visible at observatory's latitude.

2) creating a grid of nominal AltAz positions

3) acquiring for all nominal grid positions an
image from DSS

4) analyzing the obtained images with SExtractor
(optionally with astrometry.net).

5) performing the fit of the nominal and mount
positions, finally plot the results.

Status u_point as of 2016-11-13
===============================

I just completed the first release. Missing are:

- proper documentation
- EQ mount analysis
- Python unit tests

Please feel free to contact me (wildi.markus@bluewin.ch)

Status u_point.py as of 2016-11-13
==================================

I started with astropy and found that there are
differences e.g. between EQ (CIRS) to AltAz
transformations I could not explain nor did
someone on astropy@scipy.org answer.

I developed u_point.py based on libnova and added
later the astropy code for comparison again. There
are still differences and I'd be glad if someone
can point me into the right direction.

The EQ models are not usable yet.

The AltAz model does not always converge. Repeat
the fitting several times to gain confidence. I
observed that fits on simulated data do not
converge. In such cases repeat the data generation.

Status u_acquire.py as of 2016-11-13
====================================

I dry tested u_acquire.py in simulation mode and
together with RTS2 dummy devices. I do not expect
any major failures if a real AltAz mount is used.

u_acquire.py is suitable for AltAz mounts but
soon EQ mounts can be used too.

Use case
========

u_point's use case is a CCD FoV which is too small
for astrometry.net or similar to work reliably. As
targets serve "lonely" objects from Yale's Bright
Star Catalog which can be identified by a human
being by looking at the CCD image.

Of course astrometry.net is built in and a completely
unattended image acquisition and pointing model
analysis is feasible too.


Preparation: u_select.py, u_acquire.py
======================================

Script u_select.py  filters objects which are
visible at a given latitude

 u_select.py --obs-latitude m75.1 --plot

and writes it to a file. The default can be replaced
with option --observable-catalog. All u_*py scripts
have a default base path in common where files are
written and read back. The value is ./u_point_data/.
For further options use u_select.py --help.

The grid of nominal Alt Az positions to observe
is created by

 u_acquire.py --create-nominal --plot

and the result is written to nominal_positions.nml
if not specified differently. Check the plot and if
not satisfied see options --altitude-interval,
--azimuth-interval, --az-step and --alt_step for
further refinements.


Data acquisition: u_acquire.py
==============================

The data acquisition can be interrupted and resumed
at any time.

Two modes of operations exist:

1) non continuous mode
2) continuous mode

If operated in continuous mode, no user interaction
is required and the images are later analyzed by
u_analyze.py.

If operated in non continuous mode, user interaction
is required and done via telnet 127.0.0.1 usually on
port 9999 (see /tmp/u_acquire.log for the actual
setting). Allowed commands are setting a different
exposure time or redo a given nominal position ev.
with a different exposure time.

The 'ORI' (see rts2-mon, T0) coordinates are always
set by u_acquire.py. Once u_acquire.py waits for
user input, the mount can be commanded using 'OFFS'
(see rts2-mon, T0) to center the object on the CCD.

If the CCD can not be driven by RTS2 or it is not
suitable, a watch dog can be set to monitor the
directory where the FITS images are written, see
options

   --mode-watchdog
   --watchdog-directory

The final output of u_acquire.py is a book keeping
file, usually named acquired_positions.acq (see
option --acquired-position) where all necessary
information is stored.

u_acquire.py does not analyze the images.

Image analysis: u_analyze.py
============================

Once the acquisition run is completed the analysis
is done with u_analyze.py preparing the input for
u_point.py.

u_analyze.py writes RA/Dec coordinates of the brightest
star and the field center, obtained by astrometry.net,
to a second set of files, usually named:

 analyzed_positions.anl
 u_point_positions_sxtr.anl
 u_point_positions_astr.anl

In case the analysis was interrupted, positions are
read back from analyzed_positions.anl and dropped.
Only the remaining positions in acquired_positions.acq
are considered and appended to analyzed_positions.anl
The files u_point_positions*.anl provide the data of
SExtractor (sxtr) and astrometry.net (astr) separately
and can be read in by u_point.py.


Pointing model: u_point.py
==========================
The files

 u_point_positions_sxtr.anl
 u_point_positions_astr.anl

prepared in the previous step can be fed into

 ./u_point.py --base-path $BASE_DIRECTORY --mount-data  u_point_positions_sxtr.anl --plot 
 ./u_point.py --base-path $BASE_DIRECTORY --mount-data  u_point_positions_astr.anl --plot 

and the plots will show the result of the fitted
parameters as well as the raw data.


Walk through with RTS2 dummy devices
====================================

The following description walks you through a simulated
data acquisition with DSS image retrieval for an easy
comparison with the "real" sky.

Configure RTS2 with dummy devices (/etc/rts2/devices):

 #RTS2 devices configuration
 #device type    device_name     options
 camd    dummy   C0      --width 862 --height 655 --frame-transfer --localhost localhost
 teld    dummy   T0      --move fast --localhost localhost
 
u_point is not yet installed on the system's PYTHON path.

 cd $HOME/rts2/scripts/u_point
 
Create the site specific observable star catalog based on
Yale Bright Star catalog, see help for e.g. observatory
specific options

 ./u_select.py --plot --brightness-interval "6.0 7.0" --altitude-interval "10. 80" --minimum-separation 1.5
 ls -l observable.cat
 -rw-rw-r-- 1 wildi wildi 108813 Nov  6 10:38 observable.cat


Start simulated data acquisition:

 sudo bash
 systemctl start rts2 # Ubuntu 16.04, see $HOME/rts2/conf/rts2.service
 rts2-scriptexec -d C0 -s " exe ./u_acquire_fetch_dss_continuous.sh "

In a separate terminal:

 tail -f /tmp/u_acquire.log 

or at any time for a progress report plot

./u_acquire.py --plot

Red dots are remaining nominal and blue dots are acquired positions
To see DSS catalog FITS images:

 ds9 -zscale dss*.fits

The brightest star must be in the center.

Recommended terminal set up
---------------------------

For each listed command open a terminal which can be
viewed "in parallel":

 tail -f /tmp/u_acquire.log 
 telnet 127.0.0.1 9999
 ./u_acquire.py --plot;ds9 -zscale dss*fits
 rts2-scriptexec -d C0 -s " exe ./u_acquire_fetch_dss_continuous.s "
 

Pointing model analysis: u_point.py
===================================

Fetch real data and fit them

 cd ~/rts2/scripts/u_point/
 wget http://azug.minpet.unibas.ch/~wildi/mount_data_meteo.txt
 ./u_point.py --toc  --mount-data mount_data_meteo.txt --plot

the output should be similar to:

 --------------------------------------------------------
 fitted values:
 C1: horizontal telescope collimation: -339.9976 [arcsec]
 C2: constant azimuth offset         :+1024.7588 [arcsec]
 C3: tipping-mount collimation       :   +3.1370 [arcsec]
 C4: azimuth axis tilt West          : +719.9432 [arcsec]
 C5: azimuth axis tilt North         : +422.3190 [arcsec]
 C6: vertical telescope collimation  : +579.9046 [arcsec]
 C7: gravitational tube bending      :  -85.1722 [arcsec]
 /home/wildi/sw/python/v_point/lib/python3.5/site-packages/scipy/optimize/minpack.py:427: RuntimeWarning: Number of calls to function has reached maxfev = 800.
  warnings.warn(errors[info][0], RuntimeWarning)
  fit projection not converged, status: 5

and the plots appear. Ignore the warning since it is related
to a Gaussian fit. Then do a simulation

  ./u_simulate.py --sigma 0. --aa "-339.99 1024.75 3.13  719.9 422.31 579.9 -85.17" --mount-data test.dat  --step 12
  
and the output should be similar to:

 input parameters
 C1: horizontal telescope collimation: -339.9900 [arcsec]
 C2: constant azimuth offset         :+1024.7500 [arcsec]
 C3: tipping-mount collimation       :   +3.1300 [arcsec]
 C4: azimuth axis tilt West          : +719.9000 [arcsec]
 C5: azimuth axis tilt North         : +422.3100 [arcsec]
 C6: vertical telescope collimation  : +579.9000 [arcsec]
 C7: gravitational tube bending      :  -85.1700 [arcsec]
 end input parameters

and finally fit the simulated data with

 ./u_point.py --toc  --mount-data test.dat

and the output shows the parameters in good agreement

 --------------------------------------------------------
 fitted values:
 C1: horizontal telescope collimation: -339.9803 [arcsec]
 C2: constant azimuth offset         :+1031.2422 [arcsec]
 C3: tipping-mount collimation       :   +3.1193 [arcsec]
 C4: azimuth axis tilt West          : +718.4110 [arcsec]
 C5: azimuth axis tilt North         : +422.1173 [arcsec]
 C6: vertical telescope collimation  : +579.8966 [arcsec]
 C7: gravitational tube bending      :  -85.1844 [arcsec]
 /home/wildi/sw/python/v_point/lib/python3.5/site-packages/scipy/optimize/minpack.py:427: RuntimeWarning: Number of calls to function has reached maxfev = 800.
  warnings.warn(errors[info][0], RuntimeWarning)
  fit projection not converged, status: 5

And the simulated plots are as "ugly" as the data.


Main differences to Petr's gpoint
---------------------------------

u_point.py includes meteo data and has Python
bindings for libnova.so, as far as I used it.

Interestingly the AltAz model fits well without
meteo data since the tube droop parameter is
a function of Alt too. But as temperature varies
the model will fail to correct the position.

Adding a different model, e.g. J. Condon (1992)
suggested to use a Fourier transformed function,
can be done easily on the source level, at
least that's my hope.


Format of the coordinates file and units
========================================

On one line:

 date time UTC begin exposure [format iso],
 catalog RA [rad],
 catalog DEC [rad],
 mount position RA [rad],
 mount position DEC [rad],
 [
 exposure time [sec],
 temperature [deg C],
 pressure QFE [hPa],
 humidity [%]
 ]

Mount coordinates are the apparent coordinates as read
at the setting circles, while catalog coordinates are
J2000 (ICRS).
Exposure, temperature, pressure and humidity are optional.
QFE is the pressure at the observatory (not sea level).

