#!/usr/bin/python
#   rts2af-queue is a TEMPORARY fix for rts2af package to queue
#   a focus run on target OnTargetFocuse (5)
#
#   Queue rts2af targets to selector
#   (C) 2011 Petr Kubanek, Institute of Physics <kubanek@fzu.cz>
#   and a little bit Markus Wildi
#   
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   Please visit http://www.gnu.org/licenses/gpl.html for license informations.

import json
import httplib
import urllib
from optparse import OptionParser
import sys
import string
import time
import logging
import re

class Rts2Queue:
	def __init__(self,queue,url,login,password):
		self.queue = queue

		slash = url.find('/')
		if slash >= 0:
			self.prefix = url[slash:]
			self.host = url[:slash]
		else:
		  	self.prefix = ''
			self.host = url

		a = self.host.split(':')
		self.port = 80
		if len(a) > 2:
			raise Exception('too much : separating port and server')
		elif len(a) == 2:
			self.port = int(a[1])
			self.host = a[0]

		import base64
		import string

		self.hlib = httplib.HTTPConnection(self.host,self.port)

		self.headers = {'Authorization':'Basic' + string.strip(base64.encodestring(login + ':' + password))}

	def loadJson(self,path,args={}):
		self.hlib.request('GET', self.prefix + path + '?' + urllib.urlencode(args), None, self.headers)
		try:
			r = None
			try:
				r = self.hlib.getresponse()
			except httplib.BadStatusLine,ex:
				# try to reload
				self.hlib = httplib.HTTPConnection(self.host,self.port)
				self.hlib.request('GET', self.prefix + path + '?' + urllib.urlencode(args), None, self.headers)
				r = self.hlib.getresponse()
			return json.load(r)
		except Exception,ec:
			print 'Cannot parse',(self.prefix + path + '?' + urllib.urlencode(args)),':',ec
			raise ec

	def getTarget(self,name):
		try:
			return self.loadJson('/api/tbyid',{'id':int(name)})['d']
		except ValueError:
			return self.loadJson('/api/tbyname',{'n':name})['d']
			
	def queueTargets(self,ids):

		now= time.time()
		return self.loadJson('/api/cmd',{'d':'SEL','c':"queue_at {0} {1} {2} {3}".format(  self.queue, string.join(map(str,ids),' '), now, now + 1800)})

	def clearQueue(self):
		return self.loadJson('/api/cmd',{'d':'SEL','c':'clear {0}'.format(self.queue)})

	def getStateEXEC(self):
		rep0= self.loadJson('/api/get', {'d': 'EXEC', 'e' : 1})
		rep1= rep0['d']
		return rep1['current']
	def getStateFocuser(self):
		rep0= self.loadJson('/api/get', {'d': 'FOC_FLI', 'e' : 1})
		rep1= rep0['d']
		return rep1['TCMODE']


if __name__ == '__main__':
	server = 'localhost:8889'
	username = 'username'
	password = 'password'
	aftarget= '5' # depending on your installation

	unique = False

  	parser = OptionParser()

	parser.add_option("--unique", help="only accept unique target", action='store_true', dest='unique')
	parser.add_option("--clear", help="clear given queue", action='store_true',dest='clear')
	parser.add_option("--queue", help='provide queue name', action='store', dest='queue', default='plan')
	parser.add_option("--server", help="specify URL to RTS2 JSON api", action="store", dest='server', default=server)
	parser.add_option("--user",help="user name",action="store",dest='username',default=username)
	parser.add_option("--password",help="user password",action="store",dest='password',default=password)
	parser.add_option("--aftarget",help="autofocus target ID",action="store",dest='aftarget',default=aftarget)

	(options,args)=parser.parse_args()

        logformat= '%(asctime)s %(levelname)s %(message)s'
	logging.basicConfig(filename='/var/log/rts2-debug', level=logging.DEBUG, format= logformat)

	logging.debug('rts2af-queue: staring with options:{0} '.format(options))

	q = Rts2Queue(options.queue,options.server,options.username,options.password)

	# Check if currently a focus run is in progress
	current= str(q.getStateEXEC())
	# [16778242, -1, 0, 0, u'ID of current target']
        pTarget = re.compile( r'(\[[0-9]+,[ ]*)([0-9\-]+)')
	targetID = pTarget.match(current)
	if(targetID):
		if( targetID.group(2)== aftarget): 
			logging.info('rts2af-queue: a focus run is in progress, exiting ')
			logging.debug('rts2af-queue: end      for options:{0} '.format(options))
			sys.exit(0)
		else:
			logging.info('rts2af-queue: current target id: {0} '.format(targetID.group(2)))

	else:
		logging.error('rts2af-queue: could not match string: {0}, received via JSON'.format(current))


	# Check if focuser is in absolute mode
	mode= str(q.getStateFocuser())
	# [50332679,1,0,0,"temperature compensation absolute, relative to FOC_DEF, no tc"]
        pMode = re.compile( r'(\[[0-9]+,[ ]*)([0-9]+)')
	modeVal = pMode.match(mode)
	if(modeVal):
		if( modeVal.group(2)== '0'): # 0 absolute, 1 relative, 2, no temperature compensation
			logging.info('rts2af-queue: focuser is in absolute temperature compensation mode, exiting ')
			logging.debug('rts2af-queue: end      for options:{0} '.format(options))
			sys.exit(0)
		else:
			logging.info('rts2af-queue: current temperature compensation mode: {0} '.format(modeVal.group(2)))

	else:
		logging.error('rts2af-queue: could not match string: {0}, received via JSON'.format(current))


	logging.info('rts2af-queue: queueing a focus run')

	if options.clear:
		resp = q.clearQueue()
		print "cleared queue {0}: {1}".format(options.queue, resp['d']['plan_ids'][1])

	for x in args:
		tars = q.getTarget(x)
		if len(tars) == 0:
			print >> sys.stderr, "cannot find target with name {0}".format(x)
			sys.exit(1)
		if unique and len(tars) != 1:
		  	print >> sys.stderr, "target name {0} is not unique - returned target with IDs {1}".format(x,'TBD')
			sys.exit(2)

		tids = []	
		for t in tars:
		  	tids.append(t[0])
			print 'Queued to queue {0} target {1} with ID {2} on ra dec {3} {4}'.format(options.queue,t[1],t[0],t[2],t[3])
		resp = q.queueTargets(tids)
		print resp['d']['plan_ids'][1]

	logging.debug('rts2af-queue: end      for options:{0} '.format(options))
