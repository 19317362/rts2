#!/usr/bin/env python

import ds9
import argparse
import sep
import numpy as np
from astropy import wcs
from astropy.io import fits

parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,description='Too to find brightest star on the image, produce preliminary WCS based on bright stars found in images')

parser.add_argument('-v',help='verbose',action='count',dest='verbose',default=0)
parser.add_argument('--dss',help='show DSS image, match on WCS for comparsion of the fields', dest='dss', action='store_true', default=False)
parser.add_argument('--asecpix',help='image scale (arcsec/pixel)',dest='asecpix', type=float, action='store', default=0.3)
parser.add_argument('--rotang',help='basic rotational angle (degrees)',dest='rotang', type=float, action='store', default=0)
parser.add_argument('args',help='files to process',nargs='+')

options = parser.parse_args()

__DS9 = 'bsc'

def find_brightest(hdu):
	"""Find brightests stars"""
	data = np.array(hdu[0].data,np.int32)
	bkg = sep.Background(data)
	bkg.subfrom(data)
	thres = 1.5 * bkg.globalrms
	if options.verbose:
		print 'global average background: {0:.2f} rms: {1:.3f} threshold: {2:.3f}'.format(bkg.globalback, bkg.globalrms, thres)
	objects = sep.extract(data, thres)
	# order by flux
	s_objects = sorted(objects, cmp=lambda x,y: cmp(y['flux'],x['flux']))
	b_x = s_objects[0]['x']
	b_y = s_objects[0]['y']
	b_flux = s_objects[0]['flux']
	if options.verbose:
		print 'detected {0} objects',format(len(objects))
		print 'brightest at {0:.2f} {1:.2f}'.format(b_x,b_y)
		if options.verbose > 1:
			for o in objects:
				print 'object {0}'.format(o)
		d=ds9.ds9(__DS9)
		d.set('file {0}'.format(fn))
		d.set('regions','image; point({0},{1}) # point=cross 25, color=green'.format(b_x,b_y))
		if options.verbose > 1:
			w_flux = s_objects[-1]['flux']
			bb_flux = s_objects[1]['flux']
			for o in s_objects[1:]:
				w = 1 + (o['flux'] - w_flux) / (bb_flux - w_flux)
				w = np.log(w)
				w = 20 * w
				w = w if w > 1 else 1
				d.set('regions','image; point({0},{1}) # point=cross {2},color=green'.format(o['x'],o['y'],int(w)))
	return b_x,b_y

def add_wcs(fn):
	if options.verbose or options.dss:
		d = ds9.ds9(__DS9)
		d.set('frame delete all')
		d.set('frame new')

	hdu = fits.open(fn)
	x,y = find_brightest(hdu)
	b_ra = hdu[0].header['OBJRA']
	b_dec = hdu[0].header['OBJDEC']
	if options.dss:
		d = ds9.ds9(__DS9)
		d.set('dss coord {0} {1} degrees'.format(b_ra, b_dec))
		d.set('dss size 7 7')

	w = wcs.WCS(naxis=2)
	w.wcs.crpix = [x,y]
	w.wcs.crval = [b_ra,b_dec]

	rt_rad = np.radians(options.rotang)
	rt_cos = np.cos(rt_rad)
	rt_sin = np.sin(rt_rad)

	w.wcs.cd = (options.asecpix / 3600.0) * np.array([[rt_cos,rt_sin], [-rt_sin,rt_cos]], np.float)
	w.wcs.ctype = ['RA---TAN', 'DEC--TAN']

	if options.verbose > 1:
		pixcrd = np.array( [[x, y], [x + 1, y + 1], [0,0]], np.float)
		print 'some pixels', w.wcs_pix2world(pixcrd, 1)
	
	hdu[0].header.append(w.to_fits()[0].header)
	hdu.writeto('out.fits', clobber=True)

	if options.verbose:
		d = ds9.ds9(__DS9)
		d.set('frame clear 1')
		d.set('frame 1')

for fn in options.args:
	add_wcs(fn)
