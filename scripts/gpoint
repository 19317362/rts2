#!/usr/bin/env python

# g(pl)-Point - GPLed Telescope pointing model fit, as described in paper by Marc Buie:
#
# ftp://ftp.lowell.edu/pub/buie/idl/pointing/pointing.pdf 
#
# (C) 2015 Petr Kubanek <petr@kubanek.net>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import sys
import numpy as np

from math import radians,degrees,cos,sin,tan,sqrt,atan2,acos
from scipy.optimize import leastsq

import re

import argparse

# caclulates root mean squeare of vector/array
def RMS(vector):
	return np.sqrt(np.mean(np.square(vector)))

def flip_ra(a_ra,dec):
	if abs(dec) > 90:
		return (a_ra + 180) % 360
	return a_ra

def flip_dec(a_dec,dec):
	if dec > 90:
		return 180 - a_dec
	elif dec < -90:
		return -180 - a_dec
	return a_dec

class GPoint:
	# @param 
	def __init__(self,verbose=0,latitude=None):
		self.aa_ra = None
		self.verbose = verbose
		# telescope latitude - north positive
		self.latitude = latitude
		if latitude is not None:
			self.latitude_r = radians(latitude)

	# transform HA-DEc vector to ALT-AZ vector
	def equ_to_hrz(self,ha,dec):
		A = np.sin(self.latitude_r) * np.sin(dec) + np.cos(self.latitude_r) * np.cos(dec) * np.cos(ha)
		alt = np.arcsin(A)

		Z = np.arccos(A)
		Zs = np.sin(Z)
		As = (np.cos(dec) * np.sin(ha)) / Zs;
		Ac = (np.sin(self.latitude_r) * np.cos(dec) * np.cos(ha) - np.cos(self.latitude_r) * np.sin(dec)) / Zs;
		Aa = np.arctan2(As,Ac)

		return np.degrees(alt),(np.degrees(Aa) + 360) % 360

	def model_ha(self,params,a_ha,a_dec):
		return - params[4] \
			- params[5]/np.cos(a_dec) \
			+ params[6]*np.tan(a_dec) \
			- (-params[1]*np.sin(a_ha) + params[2]*np.cos(a_ha)) * np.tan(a_dec) \
			- params[3]*np.cos(self.latitude_r)*np.sin(a_ha) / np.cos(a_dec) \
			- params[7]*(np.sin(self.latitude_r) * np.tan(a_dec) + np.cos(a_dec) * np.cos(a_ha)) \
			- params[8] * a_ha

	def model_dec(self,params,a_ha,a_dec):
		return - params[0] \
			+ params[1]*np.cos(a_ha) \
			+ params[2]*np.sin(a_ha) \
			+ params[3]*(sin(self.latitude_r) * np.cos(a_dec) - cos(self.latitude_r) * np.sin(a_dec) * np.cos(a_ha))

	# Fit functions.
	# a_ha - target HA (hour angle)
	# r_ha - calculated (real) HA
	# a_dec - target DEC
	# r_dec - calculated (real) DEC
	# DEC > 90 or < -90 means telescope flipped (DEC axis continues for modelling purposes)
	def fit_model_ha(self,params,a_ha,r_ha,a_dec,r_dec):
		return a_ha - r_ha + self.model_ha(params,a_ha,a_dec)

	def fit_model_dec(self,params,a_ha,r_ha,a_dec,r_dec):
		return a_dec - r_dec + self.model_dec(params,a_ha,a_dec)

	def fit_model(self,params,a_ra,r_ra,a_dec,r_dec):
		if self.verbose:
			print 'computing', self.latitude, self.latitude_r, params, a_ra, r_ra, a_dec, r_dec
		return np.concatenate((self.fit_model_ha(params,a_ra,r_ra,a_dec,r_dec),self.fit_model_dec(params,a_ra,r_ra,a_dec,r_dec)))

	# open file, produce model
	# expected format:
	#  Observation	  MJD	   RA-MNT   DEC-MNT LST-MNT	  AXRA	  AXDEC   RA-TRUE  DEC-TRUE
	## observatory <longitude> <latitude> <altitude>
	#02a57222e0002o 57222.260012 275.7921  77.0452 233.8937  -55497734  -46831997 276.0206  77.0643
	#skip first line, use what comes next. Make correction on DEC based on axis - if above zeropoint + 90 deg, flip DEC (DEC = 180 - DEC)
	def process_file(self,filename):
		obsmatch = re.compile('#\s*observatory\s+(\S*)\s+(\S*)\s+(\S*)\s*')

		f = open(filename)
		# skip first line
		f.readline()
		line = f.readline()
		rdata = []
		while not(line == ''):
			if line[0] == '#':
				m = obsmatch.match(line)
				if m:
					if self.latitude is not None:
						sys.exit('You cannot specify latitude twice!')
					self.latitude=float(m.group(2))
			else:
				rdata.append(line.split())

			line = f.readline()

		f.close()
		
		if self.verbose:
			print "Input data",rdata

		if self.latitude is None:
			sys.exit("You must specify latitude! Either through --latitude option, or in input file. Exiting")

		self.latitude_r = radians(self.latitude)

		data = [(float(lst) - float(a_ra), float(a_dec), float(lst) - flip_ra(float(r_ra),float(a_dec)), flip_dec(float(r_dec),float(a_dec)), sn) for sn,mjd,lst,a_ra,a_dec,ax_ra,ax_dec,r_ra,r_dec in rdata]

		a_data = np.array(data)
		if self.verbose:
			print "Parsed data",a_data
	
		par_init = np.array([0,0,0,0,0,0,0,0,0])
	
		self.aa_ra = np.radians(np.array(a_data[:,0],np.float))
		self.aa_dec = np.radians(np.array(a_data[:,1],np.float))
		self.ar_ra = np.radians(np.array(a_data[:,2],np.float))
		self.ar_dec = np.radians(np.array(a_data[:,3],np.float))

		self.diff_ra = np.degrees(self.aa_ra - self.ar_ra)
		self.diff_dec = np.degrees(self.aa_dec - self.ar_dec)

		# transform to alt/az
		self.aa_alt,self.aa_az = self.equ_to_hrz(self.aa_ra,self.aa_dec)
		self.ar_alt,self.ar_az = self.equ_to_hrz(self.ar_ra,self.ar_dec)

		self.best,self.cov,self.info,self.message,self.ier = leastsq(self.fit_model,par_init,args=(self.aa_ra,self.ar_ra,self.aa_dec,self.ar_dec),full_output=True)

		# feed parameters to diff, obtain model differences. Closer to zero = better
		self.diff_model_ha = np.degrees(self.fit_model_ha(self.best,self.aa_ra,self.ar_ra,self.aa_dec,self.ar_dec))
		self.diff_model_dec = np.degrees(self.fit_model_dec(self.best,self.aa_ra,self.ar_ra,self.aa_dec,self.ar_dec))

		return self.best

	def print_params(self):
		print "Best fit",np.degrees(self.best)
		if self.verbose:
			print self.cov
			print self.info
			print self.message
			print self.ier

		print 'Zero point in DEC (") {0}'.format(degrees(self.best[0])*60.0)
		print 'Zero point in RA (") {0}'.format(degrees(self.best[4])*60.0)
		i = sqrt(self.best[1]**2 + self.best[2]**2)
		print 'Angle between true and instrumental poles (") {0}'.format(degrees(i)*60.0)
		print self.best[1],i,self.best[1]/i,acos(self.best[1]/i),atan2(self.best[2],self.best[1])
		print 'Angle between line of pole and true meridian (deg) {0}'.format(degrees(atan2(self.best[2],self.best[1]))*60.0)
		print 'Telescope tube droop in HA and DEC (") {0}'.format(degrees(self.best[3])*60.0)
		print 'Angle between optical and telescope tube axes (") {0}'.format(degrees(self.best[5])*60.0)
		print 'Mechanical orthogonality of RA and DEC axes (") {0}'.format(degrees(self.best[6])*60.0)
		print 'Dec axis flexure (") {0}'.format(degrees(self.best[7])*60.0)
		print 'HA encoder scale error ("/degree) {0}'.format(degrees(self.best[8])*60.0)

		print 'DIFF_MODEL RA',
		for d in self.diff_model_ha:
			print d * 3600.0,
		print

		print 'DIFF_MODEL DEC',
		for d in self.diff_model_dec:
			print d * 3600.0,
		print

		print 'RTS2_MODEL',
		for a in self.best:
			print a,
		print


	def print_stat(self):
		if self.verbose:
			print self.diff_ra * 3600.0
			print self.diff_dec * 3600.0

		print 'RMS RA DIFF {0}"'.format(RMS(self.diff_ra*3600))
		print 'RMS DEC DIFF {0}"'.format(RMS(self.diff_dec*3600))

		print 'RMS MODEL RA DIFF {0}"'.format(RMS(self.diff_model_ha*3600))
		print 'RMS MODEL DEC DIFF {0}"'.format(RMS(self.diff_model_dec*3600))
		print 'RMS {0}'.format(np.square(np.concatenate((self.diff_model_ha,self.diff_model_dec))*3600))

		return self.best

	def ploterrors(self,count):
		import pylab
		# count is number from command line, need real number of plots
		pcount = [3,5][count-1]
		all_error = pylab.subplot(pcount,1,1)

		all_error.plot( \
			range(0,len(self.diff_model_ha)),self.diff_model_ha * 3600.0,'g+', \
			range(0,len(self.diff_model_dec)),self.diff_model_dec * 3600.0,'g*')

		all_error.set_title('RA DEC error')
		all_error.set_ylabel('model error (arcsec)')

		
		ra_error = pylab.subplot(pcount,1,2)
		ra_error.plot(range(0,len(self.diff_ra)), self.diff_ra*3600.0, 'r+')
		ra_error.set_ylabel('RA error')

		dec_error = pylab.subplot(pcount,1,3)
		dec_error.plot(range(0,len(self.diff_dec)), self.diff_dec*3600.0, 'r*')
		dec_error.set_ylabel('DEC error')

		if count > 1:
			alt_error = pylab.subplot(pcount,1,1)
			alt_error.plot(self.aa_az, (self.aa_alt - self.ar_alt) * 3600.0, 'r.')
			alt_error.set_title('Az-Alt error')

			az_error = pylab.subplot(pcount,1,2)
			az_error.plot(self.aa_alt, (self.aa_az - self.ar_az) * 3600.0, 'r.')
			az_error.set_title('Alt-Az error')

		pylab.show()

	def plotoffsets(self,best,ha_start,ha_end,dec):
		import pylab

		ha_range = np.arange(ha_start,ha_end,0.02)
		ha_offsets = []
		dec_offsets = []
		for ha in ha_range:
			ha_offsets.append(self.model_ha(best,ha,dec))
			dec_offsets.append(self.model_dec(best,ha,dec))

		pylab.plot(ha_range,np.array(ha_offsets) * 3600.0,'b-',ha_range, np.array(dec_offsets) * 3600.0,'g-')
		pylab.show()

# Generate pointing model
def generateModel(args):
	model = GPoint(args.verbose,latitude=args.latitude)
	
	model.process_file(args.inputfiles[0])
	model.print_params()
	model.print_stat()

	if args.model_output is not None:
		f = open(args.model_output,'w+')
		f.write('RTS2_MODEL ')
		for b in model.best:
			f.write('{0} '.format(b))
		f.close()

	if args.plot > 0:
		model.ploterrors(args.plot)

def loadModel(modelfile):
	f = open(modelfile)
	line = f.readline().split()
	if line[0] != 'RTS2_MODEL' or len(line) != 10:
		sys.exit('invalid input model format')
	f.close()
	return map(lambda f:float(f),line[1:])

# Plot model offsets
def plotOffsets(args):
	if args.latitude == None:
		sys.exit('you must specify latitude as parameter')
	# load model..
	params = loadModel(args.inputfiles[0])
	
	ha_b,ha_e,dec = map(lambda f:float(f),args.plot_offsets.split(':'))
	
	model = GPoint(args.verbose,latitude=args.latitude)
	model.plotoffsets(params,ha_b,ha_e,dec)

def addModels(args):
	params=[]
	for f in args.inputfiles:
		params.append(loadModel(f))
	
	print 'RTS2_MODEL ',' '.join(map(lambda f:str(f),np.sum(params,axis=0)))

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='G-Point Model fitting and error plotting routines. Input/output file format is described in manual page (man gpoint).')
	parser.add_argument('inputfiles',help='input file(s)',type=str,nargs='+')
	parser.add_argument('-o',dest='model_output',action='store',help='model output filename')
	parser.add_argument('-p',dest='plot',action='count',help='plot graphs (more -p for more graphs)')
	parser.add_argument('-v',dest='verbose',action='count',help='verbose')
        parser.add_argument('--mnt-flip',dest='mnt_flip',action='store',help='select only observations with the given flip (1 where abs(dec)>90')
	parser.add_argument('--latitude',dest='latitude',action='store',default=None,type=float,help='observatory latitude (north is positive)')
	parser.add_argument('--model-input',dest='model_input',action='store_true',default=False,help='input file(s) are existing model file(s) to load and investigate')
	parser.add_argument('--plot-offsets',dest='plot_offsets',action='store',default=None,type=str,help='plot offsets from the model file; either specify ha start-end-dec, or start interactive mode')
	parser.add_argument('--add-models',dest='add_models',action='store_true',default=False,help='add input models together, produce output model combining both')

	args = parser.parse_args()

	if args.model_input:
		plotOffsets(args)
	elif args.add_models:
		addModels(args)
	else:
		generateModel(args)
