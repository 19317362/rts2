#!/usr/bin/env python

# g(pl)-Point - GPLed Telescope pointing model fit, as described in paper by Marc Buie:
#
# ftp://ftp.lowell.edu/pub/buie/idl/pointing/pointing.pdf 
#
# (C) 2015 Petr Kubanek <petr@kubanek.net>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import sys
import numpy as np
import rts2.libnova

from math import radians,degrees,cos,sin,tan,sqrt,atan2,acos
from scipy.optimize import leastsq

import re

import argparse

def flip_ra(a_ra,dec):
	if abs(dec) > 90:
		return (a_ra + 180) % 360
	return a_ra

def flip_dec(a_dec,dec):
	if dec > 90:
		return 180 - a_dec
	elif dec < -90:
		return -180 - a_dec
	return a_dec

def print_model_input(filename,first):
	hdulist = fits.open(filename)
	h = hdulist[0].header
	w = wcs.WCS(h)
	ra,dec = w.all_pix2world(2000,2000,0)
	tar_telra = float(h['TAR_TELRA'])
	tar_teldec = float(h['TAR_TELDEC'])
	if first:
		print "#observatory",h['SITELONG'],h['SITELAT'],h['ELEVATION']
	print(h['IMGID'],h['JD'],h['LST'],tar_telra,tar_teldec,h['AXRA'],h['AXDEC'],ra,dec)

# Computes, output, concetanetes and plot pointing models.
class GPoint:
	# @param   verbose  verbosity of the
	def __init__(self,verbose=0,latitude=None):
		self.aa_ra = None
		self.verbose = verbose
		self.indata = []
		# telescope latitude - north positive
		self.latitude = latitude
		if latitude is not None:
			self.latitude_r = np.radians(latitude)

	# transform HA-DEC vector to ALT-AZ vector
	def equ_to_hrz(self,ha,dec):
		A = np.sin(self.latitude_r) * np.sin(dec) + np.cos(self.latitude_r) * np.cos(dec) * np.cos(ha)
		alt = np.arcsin(A)

		Z = np.arccos(A)
		Zs = np.sin(Z)
		As = (np.cos(dec) * np.sin(ha)) / Zs;
		Ac = (np.sin(self.latitude_r) * np.cos(dec) * np.cos(ha) - np.cos(self.latitude_r) * np.sin(dec)) / Zs;
		Aa = np.arctan2(As,Ac)

		return np.degrees(alt),(np.degrees(Aa) + 360) % 360

	def model_ha(self,params,a_ha,a_dec):
		return - params[4] \
			- params[5]/np.cos(a_dec) \
			+ params[6]*np.tan(a_dec) \
			- (-params[1]*np.sin(a_ha) + params[2]*np.cos(a_ha)) * np.tan(a_dec) \
			- params[3]*np.cos(self.latitude_r)*np.sin(a_ha) / np.cos(a_dec) \
			- params[7]*(np.sin(self.latitude_r) * np.tan(a_dec) + np.cos(a_dec) * np.cos(a_ha)) \
			- params[8] * a_ha

	def model_dec(self,params,a_ha,a_dec):
		return - params[0] \
			+ params[1]*np.cos(a_ha) \
			+ params[2]*np.sin(a_ha) \
			+ params[3]*(np.sin(self.latitude_r) * np.cos(a_dec) - np.cos(self.latitude_r) * np.sin(a_dec) * np.cos(a_ha))

	# Fit functions.
	# a_ha - target HA (hour angle)
	# r_ha - calculated (real) HA
	# a_dec - target DEC
	# r_dec - calculated (real) DEC
	# DEC > 90 or < -90 means telescope flipped (DEC axis continues for modelling purposes)
	def fit_model_ha(self,params,a_ha,r_ha,a_dec,r_dec):
		return a_ha - r_ha + self.model_ha(params,a_ha,a_dec)

	def fit_model_dec(self,params,a_ha,r_ha,a_dec,r_dec):
		return a_dec - r_dec + self.model_dec(params,a_ha,a_dec)

	def fit_model(self,params,a_ra,r_ra,a_dec,r_dec):
		if self.verbose:
			print 'computing', self.latitude, self.latitude_r, params, a_ra, r_ra, a_dec, r_dec
		return np.concatenate((self.fit_model_ha(params,a_ra,r_ra,a_dec,r_dec),self.fit_model_dec(params,a_ra,r_ra,a_dec,r_dec)))

	# open file, produce model
	# expected format:
	#  Observation	  MJD	   RA-MNT   DEC-MNT LST-MNT	  AXRA	  AXDEC   RA-TRUE  DEC-TRUE
	## observatory <longitude> <latitude> <altitude>
	#02a57222e0002o 57222.260012 275.7921  77.0452 233.8937  -55497734  -46831997 276.0206  77.0643
	#skip first line, use what comes next. Make correction on DEC based on axis - if above zeropoint + 90 deg, flip DEC (DEC = 180 - DEC)
	def process_file(self,filename,flips):
		obsmatch = re.compile('#\s*observatory\s+(\S*)\s+(\S*)\s+(\S*)\s*')

		f = open(filename)
		# skip first line
		f.readline()
		line = f.readline()
		rdata = []
		while not(line == ''):
			if line[0] == '#':
				m = obsmatch.match(line)
				if m:
					if self.latitude is not None:
						sys.exit('You cannot specify latitude twice!')
					self.latitude=float(m.group(2))
			else:
				s = line.split()
				self.indata.append(s)
				rdata.append(s[:9])

			line = f.readline()

		f.close()
		
		if self.verbose:
			print "Input data",rdata

		if self.latitude is None:
			sys.exit("You must specify latitude! Either through --latitude option, or in input file (on #observatory line).")

		self.latitude_r = np.radians(self.latitude)

		data = [(float(lst) - float(a_ra), float(a_dec), float(lst) - flip_ra(float(r_ra),float(a_dec)), flip_dec(float(r_dec),float(a_dec)), sn, float(mjd)) for sn,mjd,lst,a_ra,a_dec,ax_ra,ax_dec,r_ra,r_dec in rdata]

		if flips == 'east':
			data = [d for d in data if abs(d[1]) > 90]
		elif flips == 'west':
			data = [d for d in data if abs(d[1]) < 90]

		a_data = np.array(data)
		if self.verbose:
			print "Parsed data",a_data
	
		par_init = np.array([0,0,0,0,0,0,0,0,0])
	
		self.aa_ra = np.array(a_data[:,0],np.float)
		self.aa_dec = np.array(a_data[:,1],np.float)
		self.ar_ra = np.array(a_data[:,2],np.float)
		self.ar_dec = np.array(a_data[:,3],np.float)

		self.mjd = np.array(a_data[:,5],np.float)

		# prepare for X ticks positions
		last_mjd = 0
		last_mjd_hour = 0
		self.mjd_ticks = {}
		self.mjd_hours = {}

		for m in range(0,len(self.mjd)):
			jd = self.mjd[m]
			if last_mjd != round(jd):
				last_mjd = round(jd)
				self.mjd_ticks[m] = last_mjd
			if last_mjd_hour != round(jd * 24):
				last_mjd_hour = round(jd * 24)
				self.mjd_hours[m] = jd

		self.diff_ra = self.aa_ra - self.ar_ra
		self.diff_dec = self.aa_dec - self.ar_dec
		self.diff_angular = rts2.libnova.angular_separation(self.aa_ra,self.aa_dec,self.ar_ra,self.ar_dec)

		self.aa_ra = np.radians(self.aa_ra)
		self.aa_dec = np.radians(self.aa_dec)
		self.ar_ra = np.radians(self.ar_ra)
		self.ar_dec = np.radians(self.ar_dec)

		# transform to alt/az
		self.aa_alt,self.aa_az = self.equ_to_hrz(self.aa_ra,self.aa_dec)
		self.ar_alt,self.ar_az = self.equ_to_hrz(self.ar_ra,self.ar_dec)

		self.best,self.cov,self.info,self.message,self.ier = leastsq(self.fit_model,par_init,args=(self.aa_ra,self.ar_ra,self.aa_dec,self.ar_dec),full_output=True)

		# feed parameters to diff, obtain model differences. Closer to zero = better
		self.diff_model_ha = np.degrees(self.fit_model_ha(self.best,self.aa_ra,self.ar_ra,self.aa_dec,self.ar_dec))
		self.diff_model_dec = np.degrees(self.fit_model_dec(self.best,self.aa_ra,self.ar_ra,self.aa_dec,self.ar_dec))

                self.diff_model_angular = rts2.libnova.angular_separation(self.aa_ra - self.diff_model_ha,self.aa_dec - self.diff_model_dec,self.ar_ra,self.ar_dec)

		return self.best

	def print_params(self):
		print "Best fit",np.degrees(self.best)
		if self.verbose:
			print self.cov
			print self.info
			print self.message
			print self.ier

		print 'Zero point in DEC (") {0}'.format(degrees(self.best[0])*60.0)
		print 'Zero point in RA (") {0}'.format(degrees(self.best[4])*60.0)
		i = sqrt(self.best[1]**2 + self.best[2]**2)
		print 'Angle between true and instrumental poles (") {0}'.format(degrees(i)*60.0)
		print self.best[1],i,self.best[1]/i,acos(self.best[1]/i),atan2(self.best[2],self.best[1])
		print 'Angle between line of pole and true meridian (deg) {0}'.format(degrees(atan2(self.best[2],self.best[1]))*60.0)
		print 'Telescope tube droop in HA and DEC (") {0}'.format(degrees(self.best[3])*60.0)
		print 'Angle between optical and telescope tube axes (") {0}'.format(degrees(self.best[5])*60.0)
		print 'Mechanical orthogonality of RA and DEC axes (") {0}'.format(degrees(self.best[6])*60.0)
		print 'Dec axis flexure (") {0}'.format(degrees(self.best[7])*60.0)
		print 'HA encoder scale error ("/degree) {0}'.format(degrees(self.best[8])*60.0)

		print 'DIFF_MODEL RA',' '.join(map(str,self.diff_model_ha*3600))
		print 'DIFF_MODEL DEC',' '.join(map(str,self.diff_model_dec*3600))
		print 'RTS2_MODEL',' '.join(map(str,self.best))


	def print_stat(self):
		# calculates root mean squeare of vector/array
		def RMS(vector):
			return np.sqrt(np.mean(np.square(vector)))

		def print_vect_stat(v):
			return 'MIN {0} MAX {1} MEAN {2} RMS {3}'.format(np.min(v),np.max(v),np.mean(v),RMS(v))

		if self.verbose:
			print 'DIFF_RA',print_vect_stat(self.diff_ra*3600)
			print 'DIFF_DEC',print_vect_stat(self.diff_dec*3600)
			print 'DIFF_ANGULAR',print_vect_stat(self.diff_angular*3600)

		print 'RMS RA DIFF',print_vect_stat(self.diff_ra*3600)
		print 'RMS DEC DIFF RMS',print_vect_stat(self.diff_dec*3600)
		print 'RMS ANGULAR SEP DIFF',print_vect_stat(self.diff_angular*3600)

		print 'RMS MODEL RA DIFF',print_vect_stat(self.diff_model_ha*3600)
		print 'RMS MODEL DEC DIFF',print_vect_stat(self.diff_model_dec*3600)
		print 'RMS MODEL ANGULAR SEP DIFF',print_vect_stat(self.diff_model_angular*3600)

		return self.best

	# set X axis to MJD data
	def set_x_axis(self,plot):
		import pylab
		def mjd_formatter(x, pos):
			try:
				return self.mjd_ticks[int(x)]
			except KeyError,ke:
				return self.mjd[int(x)]

		plot.xaxis.set_major_formatter(pylab.FuncFormatter(mjd_formatter))
		plot.set_xticks(self.mjd_ticks.keys())
		plot.set_xticks(self.mjd_hours.keys(),minor=True)
		plot.grid(which='major')
		return plot

	# set Y axis to arcsec distance
	def set_y_axis(self,plot):
		import pylab
		def arcmin_formatter(x, pos):
			return "{0}'".format(int(x / 60))
		ymin,ymax = plot.get_ylim()
		numticks = len(plot.get_yticks())
		mtscale = 60 * int(abs(ymax - ymin) / numticks / 60)
		plot.set_yticks(np.arange(ymin - ymin % 60, ymax - ymax % 60, mtscale))
		plot.set_yticks(np.arange(ymin - ymin % 60, ymax - ymax % 60, mtscale / 6.0))
		plot.yaxis.set_major_formatter(pylab.FuncFormatter(arcmin_formatter))
		return plot

	# various plots
	def plot_model_err(self,grid):
                import pylab
		all_error = pylab.subplot2grid(self.plotgrid,grid[:2],colspan=grid[2],rowspan=grid[3])
		all_error.plot(self.diff_model_ha * 3600, 'g.')
		all_error.plot(self.diff_model_dec * 3600.0,'b.')

		all_error.set_title('RA DEC error')
		all_error.set_ylabel('model error (arcsec)')
		self.set_x_axis(all_error)
		self.set_y_axis(all_error)
		return all_error

	def plot_ra_err(self,grid):
		import pylab
		ra_error = pylab.subplot2grid(self.plotgrid,grid[:2],colspan=grid[2],rowspan=grid[3])
		ra_error.plot(self.diff_ra*3600.0, 'r+')
		ra_error.set_ylabel('RA error')
		self.set_x_axis(ra_error)
		self.set_y_axis(ra_error)
		return ra_error

	def plot_dec_err(self,grid):
		import pylab
		dec_error = pylab.subplot2grid(self.plotgrid,grid[:2],colspan=grid[2],rowspan=grid[3])
		dec_error.plot(self.diff_dec*3600.0, 'r*')
		dec_error.set_ylabel('DEC error')
		self.set_x_axis(dec_error)
		self.set_y_axis(dec_error)
		return dec_error

	def plot_alt_az(self,grid,contour='',pfact=4):
		import pylab
		polar = pylab.subplot2grid(self.plotgrid,grid[:2],colspan=grid[2],rowspan=grid[3],projection='polar')
		polar.plot(np.radians(self.aa_az - 90),90 - self.aa_alt,'r.')
		polar.plot(np.radians(self.ar_az - 90),90 - self.ar_alt,'g.')
		polar.set_rmax(90)
		polar.set_xticklabels(['E','SE','S','SW','W','NW','N','NE'])
		if contour:
			X = np.radians(self.ar_az - 90)
			Y = 90 - self.ar_alt

			if contour == 'model':
				Z = self.diff_model_angular * 3600
				polar.set_title('Model differences')
			elif contour == 'real':
				Z = self.diff_angular * 3600
				polar.set_title('Real differences')

			xi = np.linspace(np.radians(-90),np.radians(271),num = 360 * pfact)
			yi = np.linspace(min(Y),max(Y),num = 90 * pfact)
			zi = pylab.griddata(X, Y, Z, xi, yi, interp='linear')
			ctf = polar.contourf(xi,yi,zi,cmap='hot')
			cbar = pylab.colorbar(ctf, orientation='horizontal', pad=0.05)
			cbar.set_ticks(range(0,int(max(Z)),60))
			cbar.ax.set_xticklabels(map("{0}'".format,range(0,int(max(Z) / 60))))
		else:
			polar.set_title('Alt-Az distribution')
                return polar

	def plot_alt_err(self,grid):
		import pylab
		alt_error = pylab.subplot2grid(self.plotgrid,grid[:2],colspan=grid[2],rowspan=grid[3])
		alt_error.plot(self.aa_az, (self.aa_alt - self.ar_alt) * 3600.0, 'r.')
		alt_error.set_autoscalex_on(False)
		alt_error.set_xlim(0,360)
		alt_error.set_xticks([0,90,180,270])
		alt_error.set_xticks([45,135,225,315],minor=True)
		self.set_y_axis(alt_error)
		alt_error.grid(which='both')
		alt_error.set_title('Az-Alt error')
		return alt_error

	def plot_az_err(self,grid):
		import pylab
		az_error = pylab.subplot2grid(self.plotgrid,grid[:2],colspan=grid[2],rowspan=grid[3])
		az_error.set_title('Alt-Az error')
		errs = np.array(map(lambda x: x if x < 180 else x - 360, (self.aa_az - self.ar_az) % 360))
		az_error.plot(self.aa_alt, errs * 3600.0, 'r.')
		self.set_y_axis(az_error)
		return az_error

	def plot(self,plots):
		import pylab
		plot = []
		grid = []

		i = 0
		rows = 1
		cols = 1
		# find grid size
		for mg in plots.split(','):
			g = [i,0,1,1]
			try:
				pmg = mg.split(':')
                                plot.append(pmg[0])
				g = map(int,pmg[1:]) + g[len(pmg[1:]):]
				grid.append(g)
			except ValueError,va:
				plot.append(mg)
				grid.append(g)
			lg = grid[-1]
			rows = max(lg[0] + lg[2],rows)
			cols = max(lg[1] + lg[3],cols)
			i += 1

		self.plotgrid = (rows,cols)
		for i in range(0,len(plot)):
			if plot[i] == 'model-err':
				self.plot_model_err(grid[i])
			elif plot[i] == 'ra-err':
				self.plot_ra_err(grid[i])
			elif plot[i] == 'dec-err':
				self.plot_dec_err(grid[i])
			elif plot[i] == 'alt-az':
				self.plot_alt_az(grid[i])
			elif plot[i] == 'alt-az-model':
				self.plot_alt_az(grid[i],'model')
			elif plot[i] == 'alt-az-real':
				self.plot_alt_az(grid[i],'real')
			elif plot[i] == 'alt-err':
				self.plot_alt_err(grid[i])
			elif plot[i] == 'az-err':
				self.plot_az_err(grid[i])
			else:
				print 'Uknown plot type',plot[i]

		pylab.show()

	def plotoffsets(self,best,ha_start,ha_end,dec):
		import pylab

		ha_range = np.arange(ha_start,ha_end,0.02)
		ha_offsets = []
		dec_offsets = []
		for ha in ha_range:
			ha_offsets.append(self.model_ha(best,ha,dec))
			dec_offsets.append(self.model_dec(best,ha,dec))

		pylab.plot(ha_range,np.array(ha_offsets) * 3600.0,'b-',ha_range, np.array(dec_offsets) * 3600.0,'g-')
		pylab.show()

	def plotpolarradec(self,count):
		import pylab

		polar = pylab.subplot(111, projection='polar')
		polar.plot(np.degrees(self.aa_ra),np.abs(np.degrees(self.aa_dec)),'r*',np.degrees(self.ar_ra),np.abs(np.degrees(self.ar_dec)),'g.')
		polar.set_rmax(90)
		pylab.show()

# Generate pointing model
def generateModel(args):
	model = GPoint(args.verbose,latitude=args.latitude)
	
	model.process_file(args.inputfiles[0],args.flips)
	model.print_params()
	model.print_stat()

	if args.model_output is not None:
		f = open(args.model_output,'w+')
		f.write('RTS2_MODEL ')
		for b in model.best:
			f.write('{0} '.format(b))
		f.close()
	if args.error_output is not None:
		f = open(args.error_output,'w+')
		out_dat = model.indata
		out_dat = np.append(out_dat,map(lambda x:[x*3600],model.diff_ra),axis=1)
		out_dat = np.append(out_dat,map(lambda x:[x*3600],model.diff_dec),axis=1)
		out_dat = np.append(out_dat,map(lambda x:[x*3600],model.diff_angular),axis=1)
		for b in out_dat:
			f.write('{0}\n'.format('\t'.join(b)))
		f.close()

	plots = args.plots
	if args.basic_plots:
		bp='model-err,ra-err,dec-err'
		plots=','.join([bp,plots]) if plots else bp

	if args.altaz_plots:
		altaz='model-err:0:0:3:1,ra-err:1:0:1:1,dec-err:2:0:1:1,alt-az-real:1:1:2:2'
		plots=','.join([altaz,plots]) if plots else altaz

	if args.altaz_heatmaps:
		altaz='alt-az-model:0:0:1:1,alt-az-real:0:1:1:1'
		plots=','.join([altaz,plots]) if plots else altaz

	if plots:
		model.plot(plots)

def loadModel(modelfile):
	f = open(modelfile)
	line = f.readline().split()
	if line[0] != 'RTS2_MODEL' or len(line) != 10:
		sys.exit('invalid input model format')
	f.close()
	return map(lambda f:float(f),line[1:])

# Plot model offsets
def plotOffsets(args):
	if args.latitude == None:
		sys.exit('you must specify latitude as parameter')
	# load model..
	params = loadModel(args.inputfiles[0])
	
	ha_b,ha_e,dec = map(lambda f:float(f),args.plot_offsets.split(':'))
	
	model = GPoint(args.verbose,latitude=args.latitude)
	model.plotoffsets(params,ha_b,ha_e,dec)

def addModels(args):
	params=[]
	for f in args.inputfiles:
		params.append(loadModel(f))
	
	print 'RTS2_MODEL ',' '.join(map(lambda f:str(f),np.sum(params,axis=0)))

if __name__ == '__main__':
	parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,description='G-Point Model fitting and error plotting routines. Input/output file format is described in manual page (man gpoint).\n\nExample usage:\n\n'\
        '\tgpoint -p model-ra,ra-err,dec-err modelin\tproduces model and model-ra,ra-err and dec-err plots')
	parser.add_argument('inputfiles',help='input file(s)',type=str,nargs='+')
	parser.add_argument('-o',dest='model_output',action='store',help='model output filename')
	parser.add_argument('-p',dest='plots',action='store',help='plot graphs (model-err,ra-err,dec-err,model-ra-err,model-dec-err,alt-az,alt-az-real,alt-az-model,alt-err,az-err)')
	parser.add_argument('--basic-plots',dest='basic_plots',action='store_true',help='plot basic graphs (model-err,ra-err,dec-err)',default=False)
	parser.add_argument('--altaz-plots',dest='altaz_plots',action='store_true',help='plot basic and Alt-az distribution graphs (model-err,ra-err,dec-err,alt-az-real)',default=False)
	parser.add_argument('--altaz-heatmaps',dest='altaz_heatmaps',action='store_true',help='plot alt-az distributions with predicted modelled and real (unmodelled) heatmaps',default=False)
	parser.add_argument('--flip',dest='flips',action='store',help='flips (both, east, west - select pointings only on given side)',default='both')
	parser.add_argument('-e',dest='error_output',action='store',help='save file with pointing and model errors')
	parser.add_argument('-v',dest='verbose',action='count',help='verbose')
        parser.add_argument('--mnt-flip',dest='mnt_flip',action='store',help='select only observations with the given flip (1 where abs(dec)>90')
	parser.add_argument('--latitude',dest='latitude',action='store',default=None,type=float,help='observatory latitude (north is positive)')
	parser.add_argument('--model-input',dest='model_input',action='store_true',default=False,help='input file(s) are existing model file(s) to load and investigate')
	parser.add_argument('--plot-offsets',dest='plot_offsets',action='store',default=None,type=str,help='plot offsets from the model file; either specify ha start-end-dec, or start interactive mode')
	parser.add_argument('--add-models',dest='add_models',action='store_true',default=False,help='add input models together, produce output model combining both')

	args = parser.parse_args()

	if args.model_input:
		plotOffsets(args)
	elif args.add_models:
		addModels(args)
	else:
		generateModel(args)
