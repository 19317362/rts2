#!/usr/bin/perl -w
#
# (C) 2009, Markus Wildi, markus.wildi@one-arcsec.org
#
#
# This script allows to communicate via EI BISYNC protocol with a SSD Drives
# frequency inverter type 650V. It allows to enquire about setting of
# parameters and set parameters to desired value.
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#   Or visit http://www.gnu.org/licenses/gpl.html.
#
# ToDo: killall rts2-executor before start
#
use strict;
use Getopt::Long qw(:config no_ignore_case) ;
use Statistics::Descriptive::Discrete;
#
use constant TRUE                   =>  1 ;
use constant FALSE                  => -1 ;
# global variables defined in this package
use vars qw(
  $scriptname
  $cvs_revision
  $cvs_date
  $verbose
  $debug
  %filter_focus_properties
  %fits_files
  $number_of_fits_files
  %number_of_images_at_foc_pos
  $number_of_objects_found_in_all_files
  %focuser_properties
  );
# ##########################################################################################
# begin default configuration
# ##########################################################################################
#
# programs
#
use constant SEXPRG  => "sex  2>/dev/null" ;
use constant FOCPRG  => "foc" ;   # Martin Jelinek's fit program
use constant FOCXPRG => "foc_x" ; # Martin Jelinek's fit program X window
use constant FITPRG  =>  FOCXPRG ; # be carefull
# 
# constants
#
#use constant FITS_DIRECTORY => "/scratch/incomming/Focusing-2009-10-15-II/Focusing-2009-10-15-II" ; # directory read from, or written to if TAKE_DATA == TRUE
use constant FITS_DIRECTORY => "/scratch/incomming/Focusing-2009-10-15" ; # directory read from, or written to if TAKE_DATA == TRUE
#use constant FITS_DIRECTORY => "/scratch/incomming/Vermes-2009-10-04" ; # directory read from, or written to if TAKE_DATA == TRUE
use constant FILTERS        => "I" ; # "U:B:V:R:I:X:Y" # filters to analyse or to use if TAKE_DATA == TRUE
use constant SELECT_RATIO   => 0.1 ; # this a threshold to avoid matching images from completely different focus runs. 
#ToDo: make a parameter
use constant MINIMUM_OBJECTS=> 10 ; #  is the minimal number of objects identified in all images
#
# if TAKE_DATA == TRUE then data taking with rts2 devices
# consitency checks are performed on the devices defined in /etc/rts2/devices
# execution is aborted if any mismatch is detected
#
use constant TAKE_DATA      => FALSE; # TRUE: data taking, FALSE: offline analysis
use constant SET_FOCUS      => FALSE; # set the focus position if only one filter is defined
use constant CCD_CAMERA     => "CD" ; # this CCD and its associate devices are used if TAKE_DATA == TRUE
#
# data taking, files
#
use constant RTS2_DEVICES   => "/etc/rts2/devices" ;
#
# sextractor configuration files, mandatory: SEXPARAM, SEXREFERENCE_PARAM from rts2-autofocus!
#
use constant SEXCFG            => "/etc/rts2/autofocus/sex-autofocus.cfg" ;
use constant SEXPARAM          => "/etc/rts2/autofocus/sex-autofocus.param" ;
use constant SEXREFERENCE_PARAM=> "/etc/rts2/autofocus/sex-autofocus-reference.param" ;
#
# set new limits after sanity checks on data, makes the fit interval symmetric with respect to $foc_pos_minimum
#
use constant SET_LIMITS_ON_SANITY_CHECKS=> TRUE ;
#
# make the focus mor robust with multiple fits to a narrower interval
# often the graphs behave oddly at the edges (far off focus)
# ToDo: use beside FWHM other quantities
#
use constant MAKE_ROBUST=> FALSE ;
#ToDo: make a parameter
use constant MINIMUM_INTERVALL=> 8 ; # unit [$filter_focus_properties{$fltr}[IND_STEP_SIZE]], minimum intervall width centered around $foc_pos_minimum
#                                               assuming that that many data points are available (might not be true).
# temporary files written by rts2-autofocus, or foc and foc_x, these will be modified with filter and date
#
use constant SEXSKY_LIST      => "/tmp/sex-autofocus-assoc-sky.list" ;
use constant SEXCATALOGUE     => "/tmp/sex-autofocus.cat" ;
use constant FIT_RESULT_FILE  => "/tmp/fit-autofocus.plt" ;
use constant DS9_REGION_FILE  => "/tmp/ds9-autofocus.reg" ;
# ToDo: discuss with Petr default focuser positions per filter (to conig file!)
# Attention: the value of the filter obtained from rts2-xmlrpcclient are numeric and not charachters
#
use constant IND_FILTER_VALUE =>  0 ; # see output of rts2-xmlrpcclient if doubtful
use constant IND_FOC_DEF      =>  1 ; # known best focus
use constant IND_LOWER_LIMIT  =>  2 ; # lower limit for fit or focuser position if TAKE_DATA == TRUE
use constant IND_UPPER_LIMIT  =>  3 ; # upper limit for fit or focuser position if TAKE_DATA == TRUE
use constant IND_STEP_SIZE    =>  4 ; # focuser step size  if TAKE_DATA == TRUE
use constant IND_EXP_TIME     =>  5 ; # exposure time used if TAKE_DATA == TRUE
%filter_focus_properties=(
'U' => [0, 5074, -1500, 1500, 100, 40], # upper and lower limits are a function of f/, ToDo: better calculate them
'B' => [1, 4712, -1500, 1500, 100, 30],
'V' => [2, 4678, -1500, 1500, 100, 20],
'R' => [3, 4766, -1500, 1500, 100, 20],
'I' => [4, 4700, -1500, 1500, 100, 20],
'X' => [5, 3270, -1500, 1500, 100, 10],
'Y' => [6, 3446, -1500, 1500, 100, 10],
 ) ;
use constant FOCUSER_RESOLUTION     =>  20 ;  # unit ticks
use constant ABSOLUTE_LOWER_LIMIT   =>  0 ;   # unit ticks 
use constant ABSOUTE_UPPER_LIMIT    =>  7000 ;# unit ticks

%focuser_properties=(
'resolution'           => FOCUSER_RESOLUTION,
'absolute_lower_limit' => ABSOLUTE_LOWER_LIMIT,
'absolute_upper_limit' => ABSOUTE_UPPER_LIMIT, 
) ;
#
# sex-autofocus analysis, this format is mandatory
#
# reference catalogue 1-14
# analysis catalogue 1-29
# 
# If something is changed here, change
# items[15] see #### ATTENTION !!!! in the code below
# /etc/rts2/autofocus/sex-autofocus.cfg
# /etc/rts2/autofocus/sex-autofocus.param
# /etc/rts2/autofocus/sex-autofocus-reference.param
#
use constant NUMBER           =>  0; #  1 Running object number
use constant X_IMAGE          =>  1; #  2 Object position along x                         [pixel]
use constant Y_IMAGE          =>  2; #  3 Object position along y                         [pixel]
use constant FLUX_ISO         =>  3; #  4 Isophotal flux                                  [count]
use constant FLUX_APER        =>  4; #  5 Flux vector within fixed circular aperture(s)   [count]
use constant FLUXERR_APER     =>  5; #  6 RMS error vector for aperture flux(es)          [count]
use constant MAG_APER         =>  6; #  7 Fixed aperture magnitude vector                 [mag]
use constant MAGERR_APER      =>  7; #  8 RMS error vector for fixed aperture mag.        [mag]
use constant FLUX_MAX         =>  8; #  9 9Peak flux above background                      [count]
use constant ISOAREA_IMAGE    =>  9; # 10 Isophotal area above Analysis threshold         [pixel**2]
use constant FLAGS            => 10; # 11 Extraction flags
use constant FWHM_IMAGE       => 11; # 12 FWHM assuming a gaussian core                   [pixel]
use constant FLUX_RADIUS      => 12; # 13 Fraction-of-light radii                         [pixel]
####################  VECTOR_ASSOC    ASSOCiated parameter vector
use constant ELLIPTICITY      => 13; # 14 1 - B_IMAGE/A_IMAGE
use constant NUMBER_REF       => 14; # 15
use constant X_IMAGE_REF      => 15; # 16
use constant Y_IMAGE_REF      => 16; # 17
use constant FLUX_ISO_REF     => 17; # 18
use constant FLUX_APER_REF    => 18; # 19
use constant FLUXERR_APER_REF => 19; # 20
use constant MAG_APER_REF     => 20; # 21
use constant MAGERR_APER_REF  => 21; # 22
use constant FLUX_MAX_REF     => 22; # 23
use constant ISOAREA_IMAGE_REF=> 23; # 24
use constant FLAGS_REF        => 24; # 25
use constant FWHM_IMAGE_REF   => 25; # 26
use constant FLUX_RADIUS_REF  => 26; # 27
use constant ELLIPTICITY_REF  => 27; # 28
use constant NUMBER_ASSOC     => 28; # Number of ASSOCiated IDs

use constant SELECTED    =>  -3 ;
use constant NOT_SELECTED=>  -2 ;
sub raw_analysis(\@)
{
    my (@items) = @{(shift)} ;

    if( $items[NUMBER_ASSOC] != 1)  # mandatory, NUMBER_ASSOC        
    {
	return NOT_SELECTED ;
    }
    if( $items[FLAGS_REF] != 0)     # mandatory, FLAGS
    {
	return NOT_SELECTED ;
    }
    if( $items[ELLIPTICITY_REF]> .3)# 0.05 ...0.3, matter of taste, ELLIPTICITY
    {
	return NOT_SELECTED ;
    }
    return SELECTED;
}
#
# ##########################################################################################
# end default configuration
# ##########################################################################################
# Do not change these
#
use constant TOO_FEW_FITS_FILES       => 10 ;
use constant SLEEP_WHILE_WAITING      =>  5 ;
use constant FOCUS_DIFFERENCE_TICKS   =>  5 ;
# indicees %fits_files
use constant IND_FILTER_FILE          =>  0 ;
use constant IND_FOC_POS_FILE         =>  1 ;
use constant IND_BINNING_FILE         =>  2 ;
use constant IND_NAXIS1_FILE          =>  3 ;
use constant IND_NAXIS2_FILE          =>  4 ;
use constant IND_ORIRA_FILE           =>  5 ;
use constant IND_ORIDEC_FILE          =>  6 ;
# indicees %sex_results
use constant IND_SEX_FOC_POS          =>  0 ;
use constant IND_SEX_DATA             =>  1 ;
use constant IND_SEX_X_IMAGE          =>  2 ; 
use constant IND_SEX_Y_IMAGE          =>  3 ; 
# indicees %objects
use constant IND_OBJ_FOC_POS          =>  0 ;
use constant IND_OBJ_DATA             =>  1 ;
use constant IND_OBJ_X_IMAGE          =>  2 ; 
use constant IND_OBJ_Y_IMAGE          =>  3 ; 
use constant IND_OBJ_NUMBER_OF_OBJECTS=>  4 ;
# auxiliary constants
use constant LOWER => 10 ;
use constant UPPER => 11 ;
$scriptname = $0;
$scriptname =~ s/.*\///g;     # remove directory path from script file path
#
######################### We start with some black magic to print on failure.
my $loaded;
BEGIN { $| = 1; }
END { print "$scriptname not ok\n" unless $loaded; }
$loaded = 1;
######################### End of black magic.
#
sub by_foc_pos{ $fits_files{$a}[1] <=> $fits_files{$b}[1]}

sub get_rts2_filter
{
    my $fltrd= shift @_ ;
    my $fltr = shift @_ ;
    
# read back the filter and the focuser position
#
    my $positive_response_filterd=0 ;
    while(1)
    {
# ToDo: does not work: chaining of arguments rts2-xmlrpcclient -G FC.FOC_DEF FW.filter
#
	my $number_filterd ;
	open( READFILTER, "rts2-xmlrpcclient -g $fltrd.filter|") or die "Can't open rts2-xmlrpcclient -g $fltrd.filter: $!" ;
	while( my $response= <READFILTER>)
	{
	    if( $response=~ m/$fltrd(.|_)filter=([0-9]+)/)
	    {
		$number_filterd= $2 ;
		if( $number_filterd== $filter_focus_properties{$fltr}[IND_FILTER_VALUE])
		{
		    $positive_response_filterd++ ;
		    #print "Got response filter $number, $filter\n";
		    last ;
		}
		else
		{
		    print "filter position not yet reached: $number_filterd!= $filter_focus_properties{$fltr}[IND_FILTER_VALUE]\n" ;
		}
	    }
	}
	close( READFILTER) ;
	if( $positive_response_filterd> 0)
	{
	    print "filter $fltrd $number_filterd= $filter_focus_properties{$fltr}[IND_FILTER_VALUE]\n" ;
	    last ;
	}
	else
	{
	    print "Sleeping ev. no response fom centrald\n" ;
	    sleep(SLEEP_WHILE_WAITING) ;
	}
    }
}
sub set_rts2_filter
{
    my $fltrd= shift @_ ;
    my $fltr = shift @_ ;

    open( SETFILTER, "rts2-xmlrpcclient -s $fltrd.FILTER $fltr|") or die "Can't open rts2-xmlrpcclient -s $fltrd.FILTER $fltr: $!" ;
    while( <SETFILTER>){}
    close( SETFILTER) ;
    return TRUE ;
}
sub get_rts2_focus
{
    my $fcsd= shift @_ ;
    my $foc = shift @_ ;

    my $positive_response_focusd=0 ;
    while(1)
    {
	my $number_focusd ;
	open( READFOCUS, "rts2-xmlrpcclient -g $fcsd.FOC_POS|") or die "Can't open rts2-xmlrpcclient -g $fcsd.FOC_POS: $!" ;
	while( my $response= <READFOCUS>)
	{
	    if( $response=~ m/$fcsd(.|_)FOC_POS=([0-9]+)/)
	    {
		my $number_focusd= $2 ;
		if( abs( $number_focusd- $foc) < FOCUS_DIFFERENCE_TICKS)
		{
		    $positive_response_focusd++ ;
		    #print "Got response focuser $number\n";
		    last ;
		}
		else
		{
			print "focus position not yet reached: abs( $number_focusd- $foc) < FOCUS_DIFFERENCE_TICKS\n" ;
		}
	    }
	}
	close( READFOCUS) ;
	if( $positive_response_focusd> 0)
	{
	    print "focus $fcsd at $number_focusd= $foc\n" ;
	    last ;
	}
	else
	{
#		print "Sleeping: $number_focusd <> $filter_focus_properties{$filter}[IND_FOC_DEF], $number_filterd <> $filter_focus_properties{$filter}[IND_FILTER_VALUE]\n" ;
	    print "Sleeping ev. no response fom centrald\n" ;
	    sleep(SLEEP_WHILE_WAITING) ;
	}
    }
}
sub set_rts2_focus_default_position
{
    my $focusd= shift @_ ;
    my $foc   = shift @_ ;

    open( SETFOC, "rts2-xmlrpcclient -s $focusd.FOC_DEF $foc|") or die "Can't open rts2-xmlrpcclient -s $focusd.FOC_DEF $foc: $!" ;
    while( <SETFOC>){}
    close( SETFOC) ;
    return TRUE ;
}
sub set_rts2_focus_target_position
{
    my $focusd= shift @_ ;
    my $foc   = shift @_ ;

    open( SETFOC, "rts2-xmlrpcclient -s $focusd.FOC_TAR $foc|") or die "Can't open rts2-xmlrpcclient -s $focusd.FOC_DEF $foc: $!" ;
    while( <SETFOC>){}
    close( SETFOC) ;
    return TRUE ;
}
sub set_rts2_fit_focus_position
{
    my $focusd   = @_ ;
    my $fit_focus= @_ ;
#
# set the focuser to the fitted position
#
#FOC_TAR Focuser target position. This shows desired focuser position. 
# If set, it will cause to move focuser to set position.
#
#FOC_DEF Default focuser position. This is used together with FOC_FOFF 
# and FOC_TOFF for autofocusing. If it is changed, target position is set 
# to sum of FOC_DEF, FOC_FOFF and FOC_TOFF.
#
#FOC_FOFF Focuser offset found during focusing. This is used to temporary 
# shift focus. If focuser driver is restarted, it is moved back to FOC_DEF 
# position.
#FOC_TOFF Focuser temporar offset used during focusing. You should use this 
# variable during focusing script to probe focus at different offsets.

    if(($fit_focus> $focuser_properties{"absolute_lower_limit"})&&($fit_focus< $focuser_properties{"absolute_upper_limit"}))
    {
	if(my $ret= set_rts2_focus_default_position( $focusd, $fit_focus)!= TRUE)
	{
	    print "Failed setting focuser $focusd to $fit_focus\n" ;
	    exit 1 ;
	}
	if(my $ret= set_rts2_focus_target_position( $focusd, $fit_focus)!= TRUE)
	{
	    print "Failed setting focuser $focusd to $fit_focus\n" ;
	    exit 1 ;
	}
    }
    else
    {
	print "focuser position $fit_focus is not within limits $focuser_properties{\"absolute_lower_limit\"}}. $focuser_properties{\"absolute_upper_limit\"}}\n" ;
    }
}
sub get_fitted_focus
{
    my $fltr           = shift @_ ;
    my $fits_dir       = shift @_ ;
    my $cfg            = shift @_ ;
    my $param          = shift @_ ;
    my $reference_param   = shift @_ ;
    my $sky_list          = shift @_ ;
    my $cat               = shift @_ ;
    my $fitprg            = shift @_ ; 
    my $fit_result_file   = shift @_ ;
    my $ds9_region_file   = shift @_ ;
    my $set_limits_on_sanity_checks = shift @_ ;
    my $make_robust       = shift @_ ;

    my $ret_get_fits= FALSE ;
    my $ret_create  = FALSE ;
    my $ret_ret     = FALSE ;
    my $ret_fit     = FALSE ;
    my $fit_focus   = FALSE ;
    my %data_points;

    my @mean_focus=(FALSE,FALSE) ;
##    my @stddev_focus=(FALSE,FALSE) ;
    $ret_get_fits= get_fits_files( $fltr, $fits_dir) ;
    if( $ret_get_fits== TRUE)
    {
	my $date_reference= `date --iso-8601=seconds --utc` ;
	chomp $date_reference ;
	$ret_create= create_reference_catalogue( $fltr, $cfg, $param, $reference_param, $sky_list, $date_reference) ;

	if( $ret_create== TRUE)
	{
	    my $date= `date --iso-8601=seconds --utc` ;
	    chomp $date ;

	    $ret_ret= retrieve_data( $fltr, $cfg, $param, $reference_param, $sky_list, $cat, $date, $date_reference, $ds9_region_file, \%data_points) ;

#ToDo: check the spatial distribution and update the reference DS9 reg file
#      calculate the center of mass and compare it with the CCD dimensions from fits file (incl. binning)
#ToDo: make a selection on spatial distribution

	    for( my $qty=0 ; $qty < 2; $qty++)
	    {
		my $lower_limit          = 0 ;
		my $upper_limit          = 1e12 ;
		my $foc_pos_minimum      = 1e12 ;
		my $foc_pos_minimum_index= 0 ;
		my $data_minimum         = 1e12 ;
		my @focuser_positions ;
		foreach my $foc_pos ( sort keys %data_points)
		{
		    push(@focuser_positions, $foc_pos) ;
		    if( $data_points{$foc_pos}[$qty] < $data_minimum)
		    {
			$foc_pos_minimum= $foc_pos ;
			$foc_pos_minimum_index++ ;
			$data_minimum= $data_points{$foc_pos}[$qty] ;
		    }
		}
# check if the location of the minimum is symmetric in respect of foc_pos (ul-ll)/2 + ul from data
#
		my $data_minimum_near_best_known_focus= TRUE ;
		if( abs($foc_pos_minimum- $filter_focus_properties{$fltr}[IND_FOC_DEF])> 3 * $focuser_properties{resolution}) # ToDo: replace constant
		{
		    $data_minimum_near_best_known_focus= FALSE ;
		    print "quantity: $qty, data minimum is at $foc_pos_minimum far away from known best focus at $filter_focus_properties{$fltr}[IND_FOC_DEF], adjust \%filter_focus_properties\n" ;
		}
		my $data_minimum_centered_to_data_limits= TRUE; 
		my $limits_minimum_difference= FALSE ;
		if ( abs($foc_pos_minimum- ($focuser_positions[$#focuser_positions]- $focuser_positions[0])/2 + $focuser_positions[0])> 3 * $focuser_properties{resolution})
		{
		    $data_minimum_centered_to_data_limits= FALSE ;
		    print "quantity: $qty, data minimum is not centered, lower limit $focuser_positions[0], data minimum $foc_pos_minimum, upper limit $focuser_positions[$#focuser_positions]\n" ;
		}
#ToDo: abs() might not be a good idea, loosing information
		if( abs($focuser_positions[$#focuser_positions]- $foc_pos_minimum) < abs($focuser_positions[0]- $foc_pos_minimum))
		{
		    $limits_minimum_difference= LOWER ;
		    if( $set_limits_on_sanity_checks== TRUE)
		    {
			$lower_limit= $foc_pos_minimum - abs($focuser_positions[$#focuser_positions]- $foc_pos_minimum) ;
		    }
		    print "quantity: $qty, lower limit set to $lower_limit\n" ;
		}
		else
		{
		    $limits_minimum_difference= UPPER ;
		    if( $set_limits_on_sanity_checks== TRUE)
		    {
			$upper_limit= $foc_pos_minimum + abs($focuser_positions[0]- $foc_pos_minimum) ;
		    }
		    print "quantity: $qty, upper limit set to $upper_limit\n" ;
		}
		$ret_fit= fit_data( $fltr, $date, $fitprg, $fit_result_file, $lower_limit, $upper_limit, $qty, \%data_points,) ;
	    
		if( $ret_fit== TRUE )
		{
		    $fit_focus = get_fitted_focus_and_plot($fltr, $fitprg, $fit_result_file, $date, $qty) ;
		    
		    if( $fit_focus != FALSE)
		    {
			$mean_focus[$qty]= $fit_focus ;
			print "quantity: $qty, filter: $fltr, fitted focus: $fit_focus\n" ;
		    } 
		    else
		    {
			print "quantity: $qty, filter: $fltr, fitted focus position undefined\n" ;
		    }
		}
		if($make_robust==TRUE)
		{
#define the most symmetric limits, there might be gaps (no images) at a specific foc_pos
# ToDo: look at the loops and try to make one out of them
		    my %symmetric_pairs;
		    if( $limits_minimum_difference== UPPER)
		    {
			for( my $ll= $focuser_positions[0]; $ll < $foc_pos_minimum; $ll += $filter_focus_properties{$fltr}[IND_STEP_SIZE])
			{
			    for( my $ul= $focuser_positions[$#focuser_positions]; $ul > $foc_pos_minimum; $ul -= $filter_focus_properties{$fltr}[IND_STEP_SIZE])
			    {
# give the fit program a fair chance
				if(abs($ul- $ll) > MINIMUM_INTERVALL * $filter_focus_properties{$fltr}[IND_STEP_SIZE]) #ToDo: replace constant
				{
				    if( abs( $ul- $foc_pos_minimum) < abs( $ll- $foc_pos_minimum))
				    {
					$symmetric_pairs{$ll}= $ul ;
					last ;
				    }
				}
			    }
			}
		    }
		    else
		    {
			for( my $ul= $focuser_positions[$#focuser_positions]; $ul > $foc_pos_minimum; $ul -= $filter_focus_properties{$fltr}[IND_STEP_SIZE])
			{
			    for( my $ll= $focuser_positions[0]; $ll < $foc_pos_minimum; $ll += $filter_focus_properties{$fltr}[IND_STEP_SIZE])
			    {
# give the fit program a fair chance
				if(abs($ul- $ll) > MINIMUM_INTERVALL * $filter_focus_properties{$fltr}[IND_STEP_SIZE]) #ToDo: replace constant
				{
				    if( abs( $ll- $foc_pos_minimum) < abs( $ul- $foc_pos_minimum))
				    {
					$symmetric_pairs{$ll}= $ul ;
					last ;
				    }
				}
			    }
			}
		    }
		    my @fitted_foci ;
		    my $mean_fit_focus= 0 ;
		    my $stddev_fit_focus= 0 ;
	    
		    foreach my $limit (sort keys %symmetric_pairs)
		    {
			$ret_fit= fit_data( $fltr, $date, $fitprg, $fit_result_file, $limit, $symmetric_pairs{$limit}, $qty, \%data_points,) ;

			if( $ret_fit== TRUE )
			{
			    $fit_focus = get_fitted_focus_and_plot($fltr, $fitprg, $fit_result_file, $date, $qty) ;
			    
			    if( $fit_focus != FALSE)
			    {
				push(@fitted_foci, $fit_focus) ; 
				print "quantity: $qty, filter: $fltr, fitted focus: $fit_focus\n" ;
			    } 
			    else
			    {
				print "quantity: $qty, filter: $fltr, fitted focus position undefined\n" ;
			    }
			}
		    }
# calculate mean and standard deviation
		    if( $#fitted_foci > 1 )
		    {
			my $stats = new Statistics::Descriptive::Discrete;
			$stats->add_data(@fitted_foci);
			print "quantity: $qty, count = ",$stats->count(),"\n";
			print "quantity: $qty, min = ",$stats->min(),"\n";
			print "quantity: $qty, max = ",$stats->max(),"\n";
			print "quantity: $qty, mean = ",$stats->mean(),"\n";
			print "quantity: $qty, standard_deviation = ",$stats->standard_deviation(),"\n";
			print "quantity: $qty, variance = ",$stats->variance(),"\n";
			print "quantity: $qty, sample_range = ",$stats->sample_range(),"\n";
			print "quantity: $qty, mode = ",$stats->mode(),"\n";
			print "quantity: $qty, median = ",$stats->median(),"\n";
		
			if($stats->standard_deviation() < $focuser_properties{"resolution"})
			{
			    print "quantity: $qty, SUCCESS\n" ;
			    $mean_focus[$qty]= $stats->mean() ;
			    #return $stats->mean() ;
			}
			else
			{
			    print "quantity: $qty, NO SUCCESS\n" ;
			    #return FALSE ;
			}    
		    }
		}
	    }
	}
    }
    
    if(($mean_focus[0] != FALSE)&&($mean_focus[1] != FALSE))
    {
	if(abs($mean_focus[0]- $mean_focus[1])  < $focuser_properties{"resolution"})
	{
	    print "SUCCESS SUCCESS: $mean_focus[0]- $mean_focus[1] < $focuser_properties{\"resolution\"}\n" ;
	    return ($mean_focus[0]+ $mean_focus[1])/2. ;
	}
	else
	{
	    print "NO SUCCESS $mean_focus[0]- $mean_focus[1] > $focuser_properties{\"resolution\"}\n" ;
	}
    }
    else
    {
	print "NO SUCCESS $mean_focus[0], $mean_focus[1]\n" ;
    }
    return FALSE ;
}
# selct all fits files in a given directory for a given filter
sub get_fits_files
{
    my $fltr           = shift @_ ;
    my $directory      = shift @_ ;
#
# extract DATA and store it, assuming one filter
#
    opendir(DIR, $directory) || die "can't opendir $directory: $!";
    my @raw_fits_files = grep { /fits$/ && -f "$directory/$_" } readdir(DIR);
    closedir DIR;
#
# select all files with given $fltr (filter)
#
    $number_of_fits_files= 0 ;
    foreach my $fits_file ( @raw_fits_files)
    {
#
# extract filter and focus position from fits
# ToDo: use cpan Astro::FITS::CFITSIO, instead imhead
# 
	my $fltr_from_file   ="" ;
	my $foc_pos_from_file="" ;
	my $binning_from_file="" ;
	my $naxis1_from_file ="" ;
	my $naxis2_from_file ="" ;
	my $orira_from_file  ="" ;
	my $oridec_from_file ="" ;

	open(IMHEAD, "imhead $fits_file|") or die "Can't start imhead: $!";
	while(<IMHEAD>){
	    my @items= split(/[=\/]/, $_) ;
	    if( $#items> 0)
	    {
		$items[1]=~ s/[ ]+//g ;
	    }
	    if( $items[0]=~ m/FILTER/)
	    {
		$fltr_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/FOC_POS/)
	    {
		$foc_pos_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/BINNING/)
	    {
		$binning_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/NAXIS1/)
	    {
		$naxis1_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/NAXIS2/)
	    {
		$naxis2_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/ORIRA/)
	    {
		$orira_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/ORIDEC/)
	    {
		$oridec_from_file=$items[1] ;
	    }
	    
	}
	close(IMHEAD) ;
##		# not mandatory:
### ATTENTION: check indicees
##		# select only those with (FOC_POS- FOC_DEF)>=LOWER_LIMIT && (FOC_POS- FOC_DEF)<=UPPER_LIMIT
##		if(( $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]- $filter_focus_properties{$fltr}[IND_FOC_DEF] >= $filter_focus_properties{$fltr}[IND_LOWER_LIMIT]) && ( $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]- $filter_focus_properties{$fltr}[IND_FOC_DEF] <= $filter_focus_properties{$fltr}[IND_UPPER_LIMIT]))
##
##
##		{
##		}
##	if(  $foc_pos_from_file ge $filter_focus_properties{$fltr}[IND_FOC_DEF]) && 
	if(( $fltr_from_file=~ m/$fltr/)&&( $foc_pos_from_file ne ""))
	{
	    $number_of_fits_files++ ;
	    $fits_files{$fits_file}[IND_FILTER_FILE] = $fltr ;
	    $fits_files{$fits_file}[IND_FOC_POS_FILE]= $foc_pos_from_file ;
	    $fits_files{$fits_file}[IND_BINNING_FILE]= $binning_from_file ;
	    $fits_files{$fits_file}[IND_NAXIS1_FILE] = $naxis1_from_file ;
	    $fits_files{$fits_file}[IND_NAXIS2_FILE] = $naxis2_from_file ;
	    $fits_files{$fits_file}[IND_ORIRA_FILE]  = $orira_from_file ;
	    $fits_files{$fits_file}[IND_ORIDEC_FILE] = $oridec_from_file ;
	    $number_of_images_at_foc_pos{$foc_pos_from_file}++ ;
	}
    }
    if( $verbose== TRUE)
    {
	foreach my $foc_pos( sort keys %number_of_images_at_foc_pos)
	{
	    printf( "filter $fltr, at foc_pos $foc_pos: %4d image%s", $number_of_images_at_foc_pos{ $foc_pos}, ($number_of_images_at_foc_pos{ $foc_pos}==1)? "": "s") ;
	}
    }
    if( $number_of_fits_files< TOO_FEW_FITS_FILES)
    {
	foreach my $fits_file ( sort by_foc_pos keys %fits_files)
	{
	    print "FILE $fits_file, $fits_files{$fits_file}[IND_FILTER_FILE], $fits_files{$fits_file}[IND_FOC_POS_FILE]\n" ;
	}
	print "in $directory" ;
	if( $number_of_fits_files> 0)
	{
	    print " only $number_of_fits_files" ;
	}
	else
	{
	    print " no" ;
	}
	print " fits files found matching filter $fltr, returning\n" ;
	return FALSE ;
    }
# stop if something is wrong, simple approach
    my @fits_file_keys= keys %fits_files ;
    foreach my $fits_file ( keys %fits_files)
    {
	if( $fits_files{$fits_file_keys[0]}[IND_BINNING_FILE] ne $fits_files{$fits_file}[IND_BINNING_FILE])
	{
	    print "binning $fits_files{$fits_file_keys[0]}[IND_BINNING_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_BINNING_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_NAXIS1_FILE] ne $fits_files{$fits_file}[IND_NAXIS1_FILE])
	{
	    print "naxis1 $fits_files{$fits_file_keys[0]}[IND_NAXIS1_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_NAXIS1_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_NAXIS2_FILE] ne $fits_files{$fits_file}[IND_NAXIS2_FILE])
	{
	    print "naxis2 $fits_files{$fits_file_keys[0]}[IND_NAXIS2_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_NAXIS2_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_ORIRA_FILE] ne $fits_files{$fits_file}[IND_ORIRA_FILE])
	{
	    print "orira $fits_files{$fits_file_keys[0]}[IND_ORIRA_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_ORIRA_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_ORIDEC_FILE] ne $fits_files{$fits_file}[IND_ORIDEC_FILE])
	{
	    print "oridec $fits_files{$fits_file_keys[0]}[IND_ORIDEC_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_ORIDEC_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}



    }
    return TRUE ;
}
sub create_reference_catalogue
{
    my $fltr           = shift @_ ;
    my $cfg            = shift @_ ;
    my $param          = shift @_ ;
    my $reference_param= shift @_ ;
    my $sky_list       = shift @_ ;
    my $date           = shift @_ ;

    my @lst_items= split(/\./, $sky_list) ;
    my $tmp_sky_list_file_name=  $lst_items[0]."-".$fltr."-".$date.".".$lst_items[1];
#
# create the reference sky list
#
    my $fits_file_reference="" ;
    foreach my $fits_file ( sort by_foc_pos keys %fits_files)
    {
	if( $fits_files{$fits_file}[IND_FOC_POS_FILE]== $filter_focus_properties{$fltr}[IND_FOC_DEF])
	{
	    $fits_file_reference= $fits_file ;
	    print "exact match of default focus position $filter_focus_properties{$fltr}[IND_FOC_DEF] in file $fits_file_reference\n" ;
	    last ;
	}
	elsif($fits_files{$fits_file}[IND_FOC_POS_FILE]> $filter_focus_properties{$fltr}[IND_FOC_DEF])
	{
	    $fits_file_reference= $fits_file ;
	    print "no exact match of default focus position $filter_focus_properties{$fltr}[IND_FOC_DEF], taking file $fits_file_reference as reference at position $fits_files{$fits_file}[IND_FOC_POS_FILE]\n" ;
	    last ;
	}
    }
    open(SEXANALYSIS, SEXPRG." $fits_file_reference -c $cfg -CATALOG_NAME $tmp_sky_list_file_name -PARAMETERS_NAME $reference_param|") or die "Can't start SExtractor: $!";
    while(<SEXANALYSIS>){}
    close(SEXANALYSIS) ;
    return TRUE ;
}
sub retrieve_data
{
    my $fltr           = shift @_ ;
    my $cfg            = shift @_ ;
    my $param          = shift @_ ;
    my $reference_param= shift @_ ;
    my $sky_list       = shift @_ ;
    my $cat            = shift @_ ; 
    my $date           = shift @_ ;
    my $date_reference = shift @_ ;
    my $ds9_region_file= shift @_ ;

    my @lst_items= split(/\./, $sky_list) ;
    my $tmp_sky_list_file_name=  $lst_items[0]."-".$fltr."-".$date_reference.".".$lst_items[1];

#
# Compare the results from file with reference catalogue
#
    my %sex_results ;
    my $region_radius= 10. ; # radius region circles
    foreach my $fits_file ( sort by_foc_pos keys %fits_files)
    {
#
# receive results from SExtractor
#
	my @cat_items= split(/\./, $cat) ;
	my $tmp_cat_file_name=  $cat_items[0]."-".$fltr."-".$date."-".$fits_files{$fits_file}[IND_FOC_POS_FILE].".".$cat_items[1];

	open(SEXANALYSIS, SEXPRG." $fits_file -c $cfg -CATALOG_NAME $tmp_cat_file_name -PARAMETERS_NAME $param -ASSOC_NAME $tmp_sky_list_file_name|") or die "Can't start SExtractor: $!";
	while(<SEXANALYSIS>){}
	close(SEXANALYSIS) ;
#
##	print "extracting from file $fits_file, with configuration -c $cfg -CATALOG_NAME $cat-$fits_files{$fits_file}[IND_FOC_POS_FILE] -PARAMETERS_NAME $param -ASSOC_NAME $tmp_sky_list_file_name\n" ;
#
# open the result file, ToDo not good at the momenet
#
	open(SEXINPUT, "$tmp_cat_file_name") or die "Can't read $tmp_cat_file_name: $!" ;
#
# open the ds9 region file and write the header
	my @ds9_items= split(/\./, $ds9_region_file) ;
	my $tmp_ds9_file_name=  $ds9_items[0]."-".$fltr."-".$date."-".$fits_files{$fits_file}[IND_FOC_POS_FILE].".".$ds9_items[1];
	open(DS9REGION, ">$tmp_ds9_file_name") or die "Can't write $tmp_ds9_file_name: $!" ;
	printf( DS9REGION "# Region file format: DS9 version 4.0\n") ;
	printf( DS9REGION "# Filename: $fits_file\n") ;
	printf( DS9REGION "global color=yellow font=\"helvetica 10 normal\" select=1 highlite=1 edit=1 move=1 delete=1 include=1 fixed=0 source\n") ;
	printf( DS9REGION "physical\n") ;

	my $number_of_objects= 0 ;
	my $number_of_selected_objects= 0 ;
	my $reference_object_number ;
	
	while(my $line=<SEXINPUT>)
	{
	    next if( $line=~ m/^#/) ; 
	    $line=~ s/[ \t\r\n]+/ /g ;
	    $line=~ s/^[ ]+//g ;
	    my @items= split(/[ ]+/, $line) ;

	    $reference_object_number= $items[14]; #### ATTENTION !!!! This is the object number in the reference catalogue
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]= FALSE ;
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]= FALSE ;
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]= FALSE ;
# select the good objects according to sextractor properties

	    my $ret= raw_analysis( @items) ; # select good objects

	    if( $ret== SELECTED)
	    {
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]= $fits_files{$fits_file}[IND_FOC_POS_FILE] ;
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE]= $items[X_IMAGE];
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE]= $items[Y_IMAGE];

		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]=       $items[FWHM_IMAGE] ; # this are the quantities to be fitted
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]= (10000.)/ $items[FLUX_MAX]   ; # this are the quantities to be fitted

		$number_of_selected_objects++ ;
#	      printf( DS9REGION "cricle\(%f,%f,20.1\) # text = {%d}\n", $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE],$sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE], $reference_object_number) ;

		printf( DS9REGION "circle\(%f,%f,%f\)\n", $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE],$sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE], $region_radius) ;
	    }
	    $number_of_objects++ ;
	}
	$region_radius +=2 ;
	close( DS9REGION) ;
	close( SEXINPUT) ;
	if( $number_of_objects> 0)
	{
	    printf("$fits_file: filter: %3s, focuser position: %5d, ratio selected / total objects: %6.3f, selected objects: %5d\n", $fltr, $fits_files{$fits_file}[IND_FOC_POS_FILE], $number_of_selected_objects/$number_of_objects, $number_of_selected_objects) ;

	    if(( $number_of_selected_objects/$number_of_objects) < SELECT_RATIO)
	    {
		foreach my $reference_object_number( keys %{$sex_results{$fits_file}})
		{
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]= FALSE ;
		}
		$number_of_images_at_foc_pos{ $fits_files{$fits_file}[IND_FOC_POS_FILE]}-- ;
		$number_of_fits_files-- ;
		printf( "$fits_file discarded due to  SELECT_RATIO %5.3f < %5.3f\n", $number_of_selected_objects/$number_of_objects, SELECT_RATIO);
	    }
	}
	else
	{
	    print "$fits_file: focuser position: $fits_files{$fits_file}[IND_FOC_POS_FILE], number of objects == 0\n" ;  
	    exit 1 ;
	}
    } # end loop fits files
    print "\n" ;
#
# count the objects
#
    print "Select objects which appeared in all files!\n" ;
    my %objects ;
    my %number_per_object ;
    foreach my $fits_file ( keys %sex_results)
    {
	foreach my $reference_object_number ( keys %{$sex_results{$fits_file}})
	{
	    if($sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS] != FALSE)
	    {
		$number_per_object{$reference_object_number}= 0 ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]= FALSE;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][0]= 0;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][1]= 0;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_X_IMAGE]= FALSE;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_Y_IMAGE]= FALSE;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_NUMBER_OF_OBJECTS]= 0;
	    }
	}
    }
    my $number_of_data_points= 0 ;
    foreach my $fits_file ( keys %sex_results)
    {
	foreach my $reference_object_number ( sort keys %{$sex_results{$fits_file}})
	{
	    if($sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS] != FALSE)
	    {
		$number_per_object{$reference_object_number}++ ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_NUMBER_OF_OBJECTS]++ ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS] = $sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][0]+= $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][1]+= $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_X_IMAGE] = $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_Y_IMAGE] = $sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE] ;
		$number_of_data_points++ ;
	    }
	}
    }
    print "number of fits files $number_of_fits_files, data points $number_of_data_points\n" ;
#
# define those objects which appeared in all files
# fit the obtained DATA values 
#
    my %objects_found_in_all_files ;
    foreach my $reference_object_number ( keys %objects)
    {
	if( $verbose== TRUE)
	{
	    printf( "filter %3s, number per object %5s: %4d\n", $fltr, $reference_object_number, $number_per_object{$reference_object_number}) ;
	}
	foreach my $fits_file ( keys %{$objects{$reference_object_number}})
	{
	    if( $number_per_object{$reference_object_number}== $number_of_fits_files) # object must appear in all files
	    {
		# the fits file names appear still in the lists, so they are here neglected
		if( $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS] != FALSE)
		{
		    if( $number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]} >0)
		    {
# creating the data point,  
#                       %data_points
			${$_[0]}{$sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]}[0] += $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]/ $number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]}; # sum data
			${$_[0]}{$sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]}[1] += $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]/ $number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]}; # sum data
# book keeping:
			$objects_found_in_all_files{$reference_object_number}[0]++ ;
			$objects_found_in_all_files{$reference_object_number}[1]    = $objects{$reference_object_number}{$fits_file}[IND_OBJ_X_IMAGE] ;
			$objects_found_in_all_files{$reference_object_number}[2]    = $objects{$reference_object_number}{$fits_file}[IND_OBJ_Y_IMAGE] ;
			$objects_found_in_all_files{$reference_object_number}[3][0]+= $objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][0] ;
			$objects_found_in_all_files{$reference_object_number}[4][1]+= $objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][1] ;
		    }
		    else
		    {
			 printf "$fits_file, foc_pos=$objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS], object $reference_object_number has number of images >>$number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]}<<\n" ;
		    }
		}
		else
		{
		    print "$fits_file, $reference_object_number has FOC_POS == FALSE\n" ;
		}
	    }
	    else
	    {
		if( $verbose== TRUE)
		{
		    printf( "not included: filter %3s, number per object %5s: %4d from file %s\n", $fltr, $reference_object_number, $number_per_object{$reference_object_number}, $fits_file) ;
		}
	    }
	}
    }
#
# write ds9 region file
#
    my @ds9_items= split(/\./, $ds9_region_file) ;
    my $tmp_file_name=  $ds9_items[0]."-".$fltr."-".$date.".".$ds9_items[1];
    
    open(DS9REGION, ">$tmp_file_name") or die "Can't write $tmp_file_name: $!" ;
    printf( DS9REGION "# Region file format: DS9 version 4.0\n") ;
    printf( DS9REGION "# Filter: $fltr, $date\n") ;
    printf( DS9REGION "global color=green font=\"helvetica 10 normal\" select=1 highlite=1 edit=1 move=1 delete=1 include=1 fixed=0 source\n") ;
    printf( DS9REGION "physical\n") ;

    $number_of_objects_found_in_all_files= 0;
    foreach my $reference_object_number ( sort keys %objects_found_in_all_files)
    {
	$number_of_objects_found_in_all_files++ ;
# ToDo: calculate the center of mass and report location, 
	printf("object: %5d, found %3d, X=%7.2f,  Y=%7.2f, data: %10.2f\n", $reference_object_number, $objects_found_in_all_files{$reference_object_number}[0], $objects_found_in_all_files{$reference_object_number}[1], $objects_found_in_all_files{$reference_object_number}[2], $objects_found_in_all_files{$reference_object_number}[3]) ;
	 # text = {This message has both a " and ' in it}

	printf( DS9REGION "circle\(%f,%f,10.1\) # text = {%d}\n", $objects_found_in_all_files{$reference_object_number}[1], 
                                                  $objects_found_in_all_files{$reference_object_number}[2], $reference_object_number) ;

	if( $objects_found_in_all_files{$reference_object_number}[0] !=$number_of_fits_files)
	{
	    print "attention something is severely wrong here counts must be equal $objects_found_in_all_files{$reference_object_number}[0] !=$number_of_fits_files\n" ;
	}
    }
    close(DS9REGION) ;

    print "found $number_of_objects_found_in_all_files objects in all files\n" ;

    if( $number_of_objects_found_in_all_files < MINIMUM_OBJECTS)
    {
	print "to few objects matched in all files, exiting\n" ;
	exit 1 ;
    }
    return TRUE ;
}
sub fit_data
{
    my $fltr           = shift @_ ; 
    my $date           = shift @_ ;
    my $fit_prg        = shift @_ ;
    my $fit_result_file= shift @_ ;
    my $lower_lmt      = shift @_ ;
    my $upper_lmt      = shift @_ ;
    my $qty            = shift @_ ;

    my @fit_items= split(/\./, $fit_result_file) ;
    my $tmp_fit_file_name ;
    if( $qty==0)
    {
	$tmp_fit_file_name=  $fit_items[0]."-".$fltr."-".$date."-FWHM_IMAGE.".$fit_items[1];
    }
    else
    {
	$tmp_fit_file_name=  $fit_items[0]."-".$fltr."-".$date."-FLUX_MAX.".$fit_items[1];
    }
    open( FIT, "| $fit_prg >$tmp_fit_file_name") or die "Can't open pipe to $fit_prg: $!" ;

##  foreach my $foc_pos ( sort keys %data_points)

    foreach my $foc_pos ( sort keys %{$_[0]})
    {
	if(($foc_pos> $lower_lmt) &&($foc_pos< $upper_lmt))
	{
	    printf( FIT "%04d    %7.5f\n", $foc_pos, ${$_[0]}{$foc_pos}[$qty]/$number_of_objects_found_in_all_files ) ; # ToDo: normalize 
	    if( $verbose==TRUE)
	    {
	#	printf(     "%04d    %7.5f\n", $foc_pos, ${$_[0]}{$foc_pos}[$qty]/$number_of_objects_found_in_all_files ) ;
	    }
	}
    }
    close(FIT) ;
    return TRUE ;
}
# read back the fitted result from file
sub get_fitted_focus_and_plot
{
    my $fltr           = shift @_ ;
    my $fitprg         = shift @_ ;
    my $fit_result_file= shift @_ ;
    my $date           = shift @_ ;
    my $qty            = shift @_ ;
#
# read back BESTFOC
#
    my $fit_focus= FALSE ;
    my @fit_result_output ;

    my @fit_items= split(/\./, $fit_result_file) ;
    my $tmp_fit_file_name ;

    if( $qty==0)
    {
	$tmp_fit_file_name=  $fit_items[0]."-".$fltr."-".$date."-FWHM_IMAGE.".$fit_items[1];
    }
    else
    {
	$tmp_fit_file_name=  $fit_items[0]."-".$fltr."-".$date."-FLUX_MAX.".$fit_items[1];
    }
    open( RES, "<$tmp_fit_file_name") or die "Can't read $tmp_fit_file_name: $!" ;

    my $minimum_y_value= 1000 ;
    my $maximum_y_value= 0 ;
    while( my $line=<RES>)
    {
	if( $line=~ m/\# BESTFOC ([0-9]+)/)
	{
	    $fit_focus= $1 ;
	}
	elsif( $line=~ m/.*?FOCUS=([0-9]+)/)
	{
	    $fit_focus= $1 ;
	}
	push( @fit_result_output, $line) ;

	if($fitprg eq FOCXPRG)
	{	
# get the y mximum value
# 5000.000000 2528.32000
	    if( $line=~ m/^([0-9]+\.[0-9]+)[ ]+([0-9]+\.[0-9]+)/)
	    {
		if( $2>$maximum_y_value)
		{
		    $maximum_y_value= $2 ;
		}
		if( $2<$minimum_y_value)
		{
		    $minimum_y_value= $2 ;
		}
	    }
	}
    }
    close( RES) ;
    if( $fit_focus== FALSE)
    {
	print "Fit did not converge\n" ;
	return FALSE ;
    }
    else
    {
# plot it if required
#
	if($fitprg eq FOCXPRG)
	{
# edit the result of fit
#
	    splice @fit_result_output, 3, 0, "set xlabel \"FOC_POS\"\n";
	    splice @fit_result_output, 4, 0, "set ylabel \"[a.u.]\"\n";
	    splice @fit_result_output, 5, 0, "set arrow from $fit_focus,$minimum_y_value to $fit_focus,$maximum_y_value nohead lw 1\n";
	    if( $qty==0)
	    {
		splice @fit_result_output, 6, 0, "set title \"rts2-autofocus, FWHM, filter $fltr, fit focus=$fit_focus, objects $number_of_objects_found_in_all_files, $date\"\n";
	    }
	    else
	    {
		splice @fit_result_output, 6, 0, "set title \"rts2-autofocus, FLUX_MAX, filter $fltr, fit focus=$fit_focus, objects $number_of_objects_found_in_all_files, $date\"\n";
	    }
#
# send additional information to gnuplot, but no comments: ^#.*$
#
	    open( PLOT, "| gnuplot -persist") or die "Can't pipe into fit process: $!" ;
	    foreach my $line (@fit_result_output)
	    {
		next if( $line=~ m/^#/) ;
# foc_x specific
		$line=~ s/plot \[\]\[0:\] \"-\" pt 5 ps 2, 0 t \"\",\\/plot \[\]\[:\] \"-\" pt 5 ps 2, 0 t \"\",\\/ ;
		printf( PLOT "%s", $line) ; 
	    }
	    close PLOT ;
	}
	return $fit_focus ;
    }
}
# print help information
#------------------------------------------------------------------------------
sub print_usage
{
  print "usage: $scriptname [options]\n\n";
  print "  options:\n";
  print "    -h --help:      print this help information.\n";
  print "       --version:   print program version information.\n";
  print "    -v --verbose:   be verbose by printing progressing to stdout.\n";
  print "    -d --debug:     print debugging information to stdout. Can be given more\n";
  print "                    than once (<=3) to increase details.\n";
}
#------------------------------------------------------------------------------
# main program
#------------------------------------------------------------------------------

my $help = 0;
my $version = 0;
$debug = FALSE;
$verbose = FALSE;
my $rts2_device_camd_default= CCD_CAMERA ;
my $rts2_device_camd= "" ;
my $rts2_device_filterd= "" ;
my $rts2_device_focusd= "" ;
my $rts2_device_camd_present= FALSE ;
my $rts2_device_filterd_present=FALSE ;
my $rts2_device_focusd_present=FALSE ;
my $rts2_device_camd_filterd= "" ;
my $rts2_device_camd_focusd= "" ;

my $fits_directory     = FITS_DIRECTORY;
my $set_focus          = SET_FOCUS; 
my $take_data          = TAKE_DATA;
my $rts2_device_file   = RTS2_DEVICES ;
my $sexcfg             = SEXCFG ;
my $sexparam           = SEXPARAM ;
my $sexreference_param = SEXREFERENCE_PARAM ;
my $sexsky_list        = SEXSKY_LIST ;
my $sexcat             = SEXCATALOGUE ;
my $fitprg             = FITPRG ;
my $fit_result_file    = FIT_RESULT_FILE ;
my $ds9_region_file    = DS9_REGION_FILE ;
my @filters            = split(/:/, FILTERS) ;
my $set_limits_on_sanity_checks= SET_LIMITS_ON_SANITY_CHECKS ;
my $make_robust        = MAKE_ROBUST ;

#ToDo: initialise!
my @rts2_filterd_filters ;
my $fit_focus= FALSE ;

if (!GetOptions("help|h"            => \$help, 
                "version"           => \$version,
                "verbose|v+"        => \$verbose,
                "debug|d+"          => \$debug,
		"fits_directory|t=s"=> \$fits_directory,
		"set_focus|f=s"     => \$set_focus,
		"take_data|o=s"     => \$take_data,
		"rts2-devices|r=s"  => \$rts2_device_file,
		"ccd|a=s"           => \$rts2_device_camd_default,
		"sexcfg|s=s"        => \$sexcfg,
		"sexparam|p=s"      => \$sexparam,
		"sexcat|c=s"        => \$sexcat,
		"fit_program|x=s"   => \$fitprg,
		"make_robust|m=i"   => \$make_robust,
               ))
{
  print_usage();
  print "No arguments given, taking defaults\n" ;
  exit 1;
}

if ($help) {
  print_usage();
  exit 0;
} elsif ($version) {
  print "$scriptname rev. $cvs_revision, $cvs_date\n";
  exit 0;
}
#
# To be done
#
##if (scalar(@ARGV) != 0) {
##  print STDERR "bad number of arguments\n";
##  print_usage();
##  exit 1;
##}
if(( $set_focus== TRUE) && ($#filters>0))
{
    print "Can not set focus while $#filters should be measured\n" ;
    print_usage();
    exit 1 ;
}
#
# check if the config files are there devices, *.cfg, *.param, and the reference *.param
#
unless ( -e $rts2_device_file)
{
    print "not found $rts2_device_file\n" ;
    exit 1;
}
unless ( -e $sexcfg)
{
    print "not found $sexcfg\n" ;
    exit 1;
}
unless ( -e $sexparam)
{
    print "not found $sexparam\n" ;
    exit 1;
}
unless ( -e $sexreference_param)
{
    print "not found $sexreference_param\n" ;
    exit 1;
}
#
# open RTS2 device file, read device names and extract the filters from wheel
# works with several ccd, fw, fc devices
##RTS2 devices configuration
##device type    device_name     options
#filterd  fli    FW     -F "U:B:V:R:I:X:Y" --fli_debug 1
#focusd   fli    FC
#camd     fli    CD     -F FC -W FW -r -23.6 -l 5 -c 0.
#filterd  fli    FR     -F "U:B:V:R:I:X:Y" --fli_debug 1
#focusd   fli    FR
#camd     fli    CR     -F FR -W FR -r -23.6 -l 5 -c 0.
#
#
# fetch first the ccd
#
open( DEVICES, $rts2_device_file) or die "Can't open $rts2_device_file: $!" ;
while(my $line=<DEVICES>)
{
    if( $line=~ m/^[ \t]*camd[ \t]+(\w+)[ \t]+(\w+)[ \t]+(.*)/)
    {
	if( $2 eq $rts2_device_camd_default)
	{
	    $rts2_device_camd= $2 ;
	    $rts2_device_camd_present= TRUE ;

	    my $arguments= $3 ;
	    if( $arguments=~ m/(--focdev|-F)[ \t]+([\w]+)/)
	    {
		$rts2_device_camd_focusd= $2 ;
	    }
	    if( $arguments=~ m/(--wheeldev|-W)[ \t]+([\w]+)/)
	    {
		$rts2_device_camd_filterd= $2 ;
	    }
	}
    }
}
close(DEVICES) ;
#
# then associated filter and focuser devices
#
open( DEVICES, $rts2_device_file) or die "Can't open $rts2_device_file: $!" ;
while(my $line=<DEVICES>)
{
    if($line=~ m/^[ \t]*filterd[ \t]+(\w+)[ \t]+($rts2_device_camd_filterd)[ \t]+(.*)/)
    {
	$rts2_device_filterd= $2 ;
	$rts2_device_filterd_present= TRUE ;
	my $arguments= $3 ;
# filter names, separated 
	if( $arguments=~ m/\-F[ \t]+"([\w:]+)"/)
	{
	    my $string= $1 ;
	    @rts2_filterd_filters=split( /[ :]/, $string) ;
	}
    }
    elsif($line=~ m/^[ \t]*focusd[ \t]+(\w+)[ \t]+($rts2_device_camd_focusd)[ \t]+(.*)/)
    {
	$rts2_device_focusd= $2 ;
	$rts2_device_focusd_present= TRUE ;
    }
}
close(DEVICES) ;
#
# Perform consistency checks
#
if( $take_data== TRUE)
{
    if( $rts2_device_camd ne $rts2_device_camd_default)
    {
	print "ccd devices $rts2_device_camd_default not present, can not take data\n" ;
	exit 1 ;
    }
    if(!(($rts2_device_camd_present== TRUE ) &&($rts2_device_filterd_present== TRUE) &&($rts2_device_focusd_present== TRUE)))
    {
	print "not all devices present,  can not take data\n" ;
	exit 1 ;
    }
#
# Compare the to camd related devices with the arguments
#
    if(!(($rts2_device_camd_focusd eq $rts2_device_focusd) && ( $rts2_device_camd_filterd eq $rts2_device_filterd)))
    {
	print "device mismatch, can not take data $rts2_device_camd_focusd eq $rts2_device_focusd, $rts2_device_camd_filterd eq $rts2_device_filterd\n" ;
	exit 1 ;
    }
#
# Compare the to filterd related filters with the arguments
#
    my $found= 0 ;
    foreach my $filter (@filters)
    {
	foreach my $rts2_filterd_filter (@rts2_filterd_filters)
	{
	    if ( $filter eq $rts2_filterd_filter)
	    {
		$found++ ;
		last ;
	    }
	}
    }
    if( $found!= $#filters+1)
    {
	print "not all filters present, can not take data $found!= $#filters+1 (see e.g. FILTERS)\n" ;
        print "filters present: " ;
	foreach my $filter (  @filters)
	{
	    printf( "$filter ") ;
	}
	printf( "\n") ;
        exit 1 ;
    }
}
#
# change to the working directory ev. write and get the list of fits files
#
chdir $fits_directory or die "Can not change to directory $fits_directory: $!" ;
#
# offline analysis, data taking
#
if( $take_data== FALSE) # offline analyis
{
    foreach my $filter (@filters)
    {
	$fit_focus= get_fitted_focus( $filter, $fits_directory, $sexcfg, $sexparam, $sexreference_param, $sexsky_list, $sexcat, $fitprg, $fit_result_file, $ds9_region_file, $set_limits_on_sanity_checks, $make_robust) ;
	undef %fits_files ;
    }
}
elsif( $take_data== TRUE) # online analysis
{
    printf( "data taking with devices: %s, %s, %s and ", $rts2_device_focusd, $rts2_device_filterd, $rts2_device_camd) ;
    foreach my $filter (  @filters)
    {
	printf( "$filter ") ;
    }
    printf( "\n") ;
    foreach my $filter ( @filters)
    {
	my $number_steps= 0 ;
	if( $filter_focus_properties{$filter}[IND_STEP_SIZE] > 0)
	{
	    $number_steps= ($filter_focus_properties{$filter}[IND_UPPER_LIMIT] - $filter_focus_properties{$filter}[IND_LOWER_LIMIT]) / $filter_focus_properties{$filter}[IND_STEP_SIZE] ;
	    $number_steps=~ s/\.[0-9]+$// ; # truncate
	}
	else
	{
	    print "define a sensible step size for filter $filter, values: $filter_focus_properties{$filter}[IND_LOWER_LIMIT], $filter_focus_properties{$filter}[IND_UPPER_LIMIT], $filter_focus_properties{$filter}[IND_STEP_SIZE]\n" ;
	    exit 1 ;
	}
# set and get filter
	set_rts2_filter($rts2_device_filterd, $filter) ;
	get_rts2_filter($rts2_device_filterd, $filter) ; 

# set and get FOC_DEF
	set_rts2_focus_default_position( $rts2_device_focusd, $filter_focus_properties{$filter}[IND_FOC_DEF]) ;
## NO	get_rts2_focus( $rts2_device_focusd, $filter_focus_properties{$filter}[IND_FOC_DEF]) ;

# start script

# This is the rts2 scipt
# e.g. rts2-scriptexec -d CD -s ' FC.FOC_TOFF=lower_limit for number_steps { E exp_time_filter FC.FOC_TOFF+=step_size } '
# 
# After rts2-scriptexec returns, all files are in the working directory
#
	print "rts2-scriptexec -d $rts2_device_camd -s ' $rts2_device_focusd.FOC_TOFF=$filter_focus_properties{$filter}[IND_LOWER_LIMIT] for $number_steps { E $filter_focus_properties{$filter}[IND_EXP_TIME] $rts2_device_focusd.FOC_TOFF+=$filter_focus_properties{$filter}[IND_STEP_SIZE] } '\n" ;
	open( CREATEFITS, "rts2-scriptexec -d $rts2_device_camd -s ' $rts2_device_focusd.FOC_TOFF=$filter_focus_properties{$filter}[IND_LOWER_LIMIT] for $number_steps { E $filter_focus_properties{$filter}[IND_EXP_TIME] $rts2_device_focusd.FOC_TOFF+=$filter_focus_properties{$filter}[IND_STEP_SIZE] } '|") or die "Can't rts2-exec: $!" ;
	while( my $response= <CREATEFITS>)
	{
	    print "R:$response" ;
	}
	close( CREATEFITS) ;

	$fit_focus= get_fitted_focus( $filter, $fits_directory, $sexcfg, $sexparam, $sexreference_param, $sexsky_list, $sexcat, $fitprg, $fit_result_file, $ds9_region_file, $set_limits_on_sanity_checks, $make_robust) ;
	undef %fits_files ;
    }
}
else
{
    print "neither data taking nor offline analysis specified, exiting\n" ;
    exit 1 ;
}
#
# set the focus (only possible when only one filter has been chosen)
#
if( $set_focus== TRUE)
{
    if( $fit_focus != FALSE)
    {
	set_rts2_fit_focus_position($rts2_device_focusd, $fit_focus)
    }
    else
    {
	print "not setting undefined focus position\n" ;
    }
}
exit 0 ;
