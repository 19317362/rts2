#!/usr/bin/perl -w
#
# (C) 2009, Markus Wildi, markus.wildi@one-arcsec.org
#
#   rts2-autofocus, see man rts2-autofocus
#   
#   
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#   Or visit http://www.gnu.org/licenses/gpl.html.
#
# ToDo: killall rts2-executor before start
#
# ToDo:  GLOBAL: if the focus run provides new settings write the results to stdout!
use strict;
use Getopt::Long qw(:config no_ignore_case) ;
#
use constant TRUE                   =>  1 ;
use constant FALSE                  => -1 ;
# global variables defined in this package
use vars qw(
  $scriptname
  $cvs_revision
  $cvs_date
  $verbose
  %filter_focus_properties
  %fits_files
  $number_of_fits_files
  %number_of_images_at_foc_pos
  $number_of_objects_found_in_all_files
  $number_of_reference_objects
  %focuser_properties
  );
# ##########################################################################################
# begin default configuration
# ##########################################################################################
#
# programs
#
use constant SEXPRG  => "sex  2>/dev/null" ;
use constant FOCROOTI=> "rts2_fit_focus 1" ; # interactive
use constant FOCROOTB=> "rts2_fit_focus 0" ; # "batch"
use constant FITPRG  => FOCROOTI  ; # 
# 
# constants
#
use constant FITS_DIRECTORY => "/scratch/incomming/Focusing-2009-10-30/test-run-10" ; # the data directory
use constant FILTERS        => "X" ;  # "U:B:V:R:I:X:Y" # filters to analyse or to use if TAKE_DATA == TRUE
use constant SELECT_RATIO   => 0.05 ; # this a threshold to avoid matching images from completely different focus runs.
#                                       $number_of_selected_objects/$number_of_reference_objects 
#ToDo: make a parameter
use constant MINIMUM_OBJECTS=> 5 ; #  is the minimal number of objects identified in all images
#
# if TAKE_DATA == TRUE then data taking with rts2 devices
# consistency checks are performed on the devices defined in /etc/rts2/devices
# execution is aborted if any mismatch is detected
#
use constant TAKE_DATA       => FALSE; # TRUE: data taking, FALSE: offline analysis
use constant SET_FOCUS       => FALSE; # set the focus position if only one filter is defined
use constant CCD_CAMERA      => "CD" ; # this CCD and its associate devices are used if TAKE_DATA == TRUE
use constant CCD_BINNING     => 1    ; # 0: 1x1, 1: 2x2,.... see your drver
use constant FIND_ROUGH_FOCUS=> TRUE;  # auto focus, nothing is known about focus position, valid for TAKE_DATA == (TRUE|FALSE)
use constant INCLUDE_ROUGH_FOCUS_RUN     => TRUE; # rough focus run images are ev. far off the extrema, valid for TAKE_DATA == (TRUE|FALSE) 
#                                                   images extension .fits is renamed to .fitsROUGH_FOCUS_RUN_EXTENSION (see below)
use constant NUMBER_OF_ROUGH_FOCUS_IMAGES=> 10;   # used if TAKE_DATA == (TRUE)
use constant FOCAL_RATIO     => 7 ;    # telescope's focal ratio
# data taking, files
#
use constant RTS2_DEVICES   => "/etc/rts2/devices" ;
# sextractor configuration files, mandatory: SEXPARAM, SEXREFERENCE_PARAM from rts2-autofocus!
#
use constant SEXCFG            => "/etc/rts2/autofocus/sex-autofocus.cfg" ;
use constant SEXPARAM          => "/etc/rts2/autofocus/sex-autofocus.param" ;
use constant SEXREFERENCE_PARAM=> "/etc/rts2/autofocus/sex-autofocus-reference.param" ;
# set new limits after sanity checks on data, makes the fit interval symmetric with respect to $foc_pos_minimum
#
use constant SET_LIMITS_ON_SANITY_CHECKS=> TRUE ;
# temporary files written by rts2-autofocus, these will be modified with filter, date and ev. filename.
#
use constant SEXSKY_LIST      => "/tmp/sex-autofocus-assoc-sky.list" ;
use constant SEXCATALOGUE     => "/tmp/sex-autofocus.cat" ;
use constant SEX_TMP_CATALOGUE=> "/tmp/sex-autofocus-tmp.cat" ;
use constant FIT_RESULT_FILE  => "/tmp/fit-autofocus.dat" ;
use constant DS9_REGION_FILE  => "/tmp/ds9-autofocus.reg" ;
# ToDo: discuss with Petr default focuser positions per filter (to conig file!)
# Attention: the value of the filter obtained from rts2-xmlrpcclient are numeric and not characters
#
use constant IND_FILTER_VALUE =>  0 ; # see output of rts2-xmlrpcclient if doubtful
use constant IND_FOC_DEF      =>  1 ; # known best focus
use constant IND_LOWER_LIMIT  =>  2 ; # lower limit for fit or focuser position if TAKE_DATA == TRUE
use constant IND_UPPER_LIMIT  =>  3 ; # upper limit for fit or focuser position if TAKE_DATA == TRUE
use constant IND_STEP_SIZE    =>  4 ; # focuser step size  if TAKE_DATA == TRUE
use constant IND_EXP_TIME     =>  5 ; # exposure time used if TAKE_DATA == TRUE
#
%filter_focus_properties=(
'U' => [0, 5074, -1500, 1500, 100, 40], # upper and lower limits are a function of f/, ToDo: better calculate them
'B' => [1, 4712, -1500, 1500, 100, 30],
'V' => [2, 4678, -1500, 1500, 100, 20],
'R' => [3, 4766, -1500, 1500, 100, 20],
'I' => [4, 4700, -1500, 1500, 100, 20],
'X' => [5, 3270, -1500, 1500, 100, 10],
'Y' => [6, 3446, -1500, 1500, 100, 10],
 ) ;
use constant FOCUSER_RESOLUTION     =>  20 ;   # unit ticks
use constant ABSOLUTE_LOWER_LIMIT   =>  1501 ; # unit ticks 
use constant ABSOLUTE_UPPER_LIMIT   =>  6002 ; # unit ticks
#
%focuser_properties=(
'resolution'           => FOCUSER_RESOLUTION,
'absolute_lower_limit' => ABSOLUTE_LOWER_LIMIT,
'absolute_upper_limit' => ABSOLUTE_UPPER_LIMIT, 
) ;
#
# sex-autofocus analysis, this format is mandatory
#
# reference catalogue 1-14
# analysis catalogue 1-29
# 
#
# /etc/rts2/autofocus/sex-autofocus.cfg
# /etc/rts2/autofocus/sex-autofocus.param
# /etc/rts2/autofocus/sex-autofocus-reference.param
#
use constant NUMBER           =>  0; #  1 Running object number
use constant X_IMAGE          =>  1; #  2 Object position along x                         [pixel]
use constant Y_IMAGE          =>  2; #  3 Object position along y                         [pixel]
use constant FLUX_ISO         =>  3; #  4 Isophotal flux                                  [count]
use constant FLUX_APER        =>  4; #  5 Flux vector within fixed circular aperture(s)   [count]
use constant FLUXERR_APER     =>  5; #  6 RMS error vector for aperture flux(es)          [count]
use constant MAG_APER         =>  6; #  7 Fixed aperture magnitude vector                 [mag]
use constant MAGERR_APER      =>  7; #  8 RMS error vector for fixed aperture mag.        [mag]
use constant FLUX_MAX         =>  8; #  9 9Peak flux above background                     [count]
use constant ISOAREA_IMAGE    =>  9; # 10 Isophotal area above Analysis threshold         [pixel**2]
use constant FLAGS            => 10; # 11 Extraction flags
use constant FWHM_IMAGE       => 11; # 12 FWHM assuming a gaussian core                   [pixel]
use constant FLUX_RADIUS      => 12; # 13 Fraction-of-light radii                         [pixel]
use constant ELLIPTICITY      => 13; # 14 1 - B_IMAGE/A_IMAGE
####################  VECTOR_ASSOC    ASSOCiated parameter vector
use constant NUMBER_REF       => 14; # 15
use constant X_IMAGE_REF      => 15; # 16
use constant Y_IMAGE_REF      => 16; # 17
use constant FLUX_ISO_REF     => 17; # 18
use constant FLUX_APER_REF    => 18; # 19
use constant FLUXERR_APER_REF => 19; # 20
use constant MAG_APER_REF     => 20; # 21
use constant MAGERR_APER_REF  => 21; # 22
use constant FLUX_MAX_REF     => 22; # 23
use constant ISOAREA_IMAGE_REF=> 23; # 24
use constant FLAGS_REF        => 24; # 25
use constant FWHM_IMAGE_REF   => 25; # 26
use constant FLUX_RADIUS_REF  => 26; # 27
use constant ELLIPTICITY_REF  => 27; # 28
use constant NUMBER_ASSOC     => 28; # Number of ASSOCiated IDs
# used in @event_scalers
use constant SELECTED    =>  0 ;
use constant NOT_NUMBER_ASSOC   =>  1 ;
use constant NOT_FLAGS_REF      =>  2 ;
use constant NOT_ELLIPTICITY_REF=>  3 ;
#
sub raw_analysis(\@)
{
    my (@items) = @{(shift)} ;

    if( $items[NUMBER_ASSOC] != 1)  # mandatory, NUMBER_ASSOC, sex.cfg is configured to write only MATCHED objects        
    {
	return NOT_NUMBER_ASSOC ;
    }
    if( $items[FLAGS_REF] != 0)     # mandatory, FLAGS
    {
	return NOT_FLAGS_REF ;
    }
    if( $items[ELLIPTICITY_REF]> .1)# 0.05 ...0.3, matter of taste, ELLIPTICITY
    {
	return NOT_ELLIPTICITY_REF ;
    }
    return SELECTED;
}
# ##########################################################################################
# end default configuration
# ##########################################################################################
# Do not change these
#
use constant TOO_FEW_FITS_FILES       => 10 ;
use constant SLEEP_WHILE_WAITING      =>  5 ;
use constant FOCUS_DIFFERENCE_TICKS   =>  5 ;
# indicees %fits_files
use constant IND_FILTER_FILE          =>  0 ;
use constant IND_FOC_POS_FILE         =>  1 ;
use constant IND_BINNING_FILE         =>  2 ;
use constant IND_NAXIS1_FILE          =>  3 ;
use constant IND_NAXIS2_FILE          =>  4 ;
use constant IND_ORIRA_FILE           =>  5 ;
use constant IND_ORIDEC_FILE          =>  6 ;
# indicees %sex_results
use constant IND_SEX_FOC_POS          =>  0 ;
use constant IND_SEX_DATA             =>  1 ;
use constant IND_SEX_X_IMAGE          =>  2 ; 
use constant IND_SEX_Y_IMAGE          =>  3 ; 
# indicees %objects
use constant IND_OBJ_FOC_POS          =>  0 ;
use constant IND_OBJ_DATA             =>  1 ;
use constant IND_OBJ_X_IMAGE          =>  2 ; 
use constant IND_OBJ_Y_IMAGE          =>  3 ; 
use constant IND_OBJ_NUMBER_OF_OBJECTS=>  4 ;
# auxiliary constants
use constant LOWER => 10 ;
use constant UPPER => 11 ;
use constant ROUGH_FOCUS_RUN_EXTENSION => "_rough_focus_run" ;

$scriptname = $0;
$scriptname =~ s/.*\///g;     # remove directory path from script file path
#
######################### We start with some black magic to print on failure.
my $loaded;
BEGIN { $| = 1; }
END { print "$scriptname not ok\n" unless $loaded; }
$loaded = 1;
######################### End of black magic.
#
# calculate exposure time as a function of focal ratio and distance from the focal plane
sub exposure_time
{
    my $exposure_time_at_focus= shift @_ ;
    my $foc_pos_at_focus = shift @_ ;
    my $foc_pos = shift @_ ;
}
# define the focuser positions
sub focuser_position
{
    my $foc_pos_current = shift @_ ;
    my $foc_pos_at_focus= shift @_ ;
    my $foc_pos_next= FALSE ;
    return $foc_pos_next ;
}
sub by_foc_pos{ $fits_files{$a}[1] <=> $fits_files{$b}[1]}

sub get_rts2_filter
{
    my $fltrd= shift @_ ;
    my $fltr = shift @_ ;
# read back the filter and the focuser position
#
    my $positive_response_filterd=0 ;
    while(1)
    {
# ToDo: does not work: chaining of arguments rts2-xmlrpcclient -G FC.FOC_DEF FW.filter
#
	my $number_filterd ;
	open( READFILTER, "rts2-xmlrpcclient -g $fltrd.filter|") or die "Can't open rts2-xmlrpcclient -g $fltrd.filter: $!" ;
	while( my $response= <READFILTER>)
	{
	    if( $response=~ m/$fltrd(.|_)filter=([0-9]+)/)
	    {
		$number_filterd= $2 ;
		if( $number_filterd== $filter_focus_properties{$fltr}[IND_FILTER_VALUE])
		{
		    $positive_response_filterd++ ;
		    #print "Got response filter $number, $filter\n";
		    last ;
		}
		else
		{
		    print "get_rts2_filter: filter position not yet reached: $number_filterd!= $filter_focus_properties{$fltr}[IND_FILTER_VALUE]\n" ;
		}
	    }
	}
	close( READFILTER) ;
	if( $positive_response_filterd> 0)
	{
	    print "get_rts2_filter: filter $fltrd $number_filterd= $filter_focus_properties{$fltr}[IND_FILTER_VALUE]\n" ;
	    last ;
	}
	else
	{
	    print "get_rts2_filter: sleeping ev. no response fom centrald\n" ;
	    sleep(SLEEP_WHILE_WAITING) ;
	}
    }
}
sub set_rts2_filter
{
    my $fltrd= shift @_ ;
    my $fltr = shift @_ ;

    open( SETFILTER, "rts2-xmlrpcclient -s $fltrd.FILTER $fltr|") or die "set_rts2_filter: can't open rts2-xmlrpcclient -s $fltrd.FILTER $fltr: $!" ;
    while( <SETFILTER>){}
    close( SETFILTER) ;
    return TRUE ;
}
sub get_rts2_focus
{
    my $fcsd= shift @_ ;
    my $foc = shift @_ ;

    my $positive_response_focusd=0 ;
    while(1)
    {
	my $number_focusd ;
	open( READFOCUS, "rts2-xmlrpcclient -g $fcsd.FOC_POS|") or die "get_rts2_focus: can't open rts2-xmlrpcclient -g $fcsd.FOC_POS: $!" ;
	while( my $response= <READFOCUS>)
	{
	    if( $response=~ m/$fcsd(.|_)FOC_POS=([0-9]+)/)
	    {
		my $number_focusd= $2 ;
		if( abs( $number_focusd- $foc) < FOCUS_DIFFERENCE_TICKS)
		{
		    $positive_response_focusd++ ;
		    #print "Got response focuser $number\n";
		    last ;
		}
		else
		{
			print "get_rts2_focus: focus position not yet reached: abs( $number_focusd- $foc) < FOCUS_DIFFERENCE_TICKS\n" ;
		}
	    }
	}
	close( READFOCUS) ;
	if( $positive_response_focusd> 0)
	{
	    print "get_rts2_focus: focus $fcsd at $number_focusd= $foc\n" ;
	    last ;
	}
	else
	{
	    print "get_rts2_focus: sleeping ev. no response fom centrald\n" ;
	    sleep(SLEEP_WHILE_WAITING) ;
	}
    }
}
sub set_rts2_focus_default_position
{
    my $focusd= shift @_ ;
    my $foc   = shift @_ ;

    open( SETFOC, "rts2-xmlrpcclient -s $focusd.FOC_DEF $foc|") or die "set_rts2_focus_default_position: can't open rts2-xmlrpcclient -s $focusd.FOC_DEF $foc: $!" ;
    while( <SETFOC>){}
    close( SETFOC) ;
    return TRUE ;
}
sub set_rts2_focus_target_position
{
    my $focusd= shift @_ ;
    my $foc   = shift @_ ;

    open( SETFOC, "rts2-xmlrpcclient -s $focusd.FOC_TAR $foc|") or die "set_rts2_focus_target_position: can't open rts2-xmlrpcclient -s $focusd.FOC_DEF $foc: $!" ;
    while( <SETFOC>){}
    close( SETFOC) ;
    return TRUE ;
}
sub set_rts2_fit_focus_position
{
    my $focusd   = @_ ;
    my $fit_focus= @_ ;
#
# set the focuser to the fitted position
#
#FOC_TAR Focuser target position. This shows desired focuser position. 
# If set, it will cause to move focuser to set position.
#
#FOC_DEF Default focuser position. This is used together with FOC_FOFF 
# and FOC_TOFF for autofocusing. If it is changed, target position is set 
# to sum of FOC_DEF, FOC_FOFF and FOC_TOFF.
#
#FOC_FOFF Focuser offset found during focusing. This is used to temporary 
# shift focus. If focuser driver is restarted, it is moved back to FOC_DEF 
# position.
#FOC_TOFF Focuser temporary offset used during focusing. You should use this 
# variable during focusing script to probe focus at different offsets.

    if(($fit_focus> $focuser_properties{"absolute_lower_limit"})&&($fit_focus< $focuser_properties{"absolute_upper_limit"}))
    {
	if(my $ret= set_rts2_focus_default_position( $focusd, $fit_focus)!= TRUE)
	{
	    print "set_rts2_fit_focus_position: failed setting focuser $focusd to $fit_focus\n" ;
	    exit 1 ;
	}
	if(my $ret= set_rts2_focus_target_position( $focusd, $fit_focus)!= TRUE)
	{
	    print "set_rts2_fit_focus_position: failed setting focuser $focusd to $fit_focus\n" ;
	    exit 1 ;
	}
    }
    else
    {
	print "set_rts2_fit_focus_position: focuser position $fit_focus is not within limits $focuser_properties{\"absolute_lower_limit\"}}. $focuser_properties{\"absolute_upper_limit\"}}\n" ;
    }
}
# select all fits files in a given directory for a given filter
sub get_fits_files
{
    my $fltr                     = shift @_ ;
    my $directory                = shift @_ ;
    my $include_rough_focus_run  = shift @_ ;
    my $rough_focus_run_extension= ROUGH_FOCUS_RUN_EXTENSION ;
# extract DATA and store it, assuming one filter
#
    opendir(DIR, $directory) || die "get_fits_files: can't opendir $directory: $!";

    my @raw_fits_files ;

    if( $include_rough_focus_run== TRUE)
    {
	@raw_fits_files = grep { /(fits|$rough_focus_run_extension)$/ && -f "$directory/$_" } readdir(DIR);
    }
    else
    {
	@raw_fits_files = grep { /fits$/ && -f "$directory/$_" } readdir(DIR);
    }

    closedir DIR;
# select all files with given $fltr (filter)
#
    $number_of_fits_files= 0 ;
    foreach my $fits_file ( @raw_fits_files)
    {
	if(( $fits_file=~ /$rough_focus_run_extension$/) && ($verbose==TRUE))
	{
	    print "get_fits_files: including $fits_file\n" ;
	}
# extract filter and focus position from fits
# ToDo: use cpan Astro::FITS::CFITSIO, instead imhead
# 
	my $fltr_from_file   ="" ;
	my $foc_pos_from_file="" ;
	my $binning_from_file="" ;
	my $naxis1_from_file ="" ;
	my $naxis2_from_file ="" ;
	my $orira_from_file  ="" ;
	my $oridec_from_file ="" ;

	open(IMHEAD, "imhead $fits_file|") or die "get_fits_files: can't start imhead: $!";
	while(<IMHEAD>){
	    my @items= split(/[=\/]/, $_) ;
	    if( $#items> 0)
	    {
		$items[1]=~ s/[ ]+//g ;
	    }
	    if( $items[0]=~ m/FILTER/)
	    {
		$fltr_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/FOC_POS/)
	    {
		$foc_pos_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/BINNING/)
	    {
		$binning_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/NAXIS1/)
	    {
		$naxis1_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/NAXIS2/)
	    {
		$naxis2_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/ORIRA/)
	    {
		$orira_from_file=$items[1] ;
	    }
	    elsif( $items[0]=~ m/ORIDEC/)
	    {
		$oridec_from_file=$items[1] ;
	    }
	}
	close(IMHEAD) ;
##		# not mandatory:
### ATTENTION: check indicees
##		# select only those with (FOC_POS- FOC_DEF)>=LOWER_LIMIT && (FOC_POS- FOC_DEF)<=UPPER_LIMIT
##		if(( $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]- $filter_focus_properties{$fltr}[IND_FOC_DEF] >= $filter_focus_properties{$fltr}[IND_LOWER_LIMIT]) && ( $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]- $filter_focus_properties{$fltr}[IND_FOC_DEF] <= $filter_focus_properties{$fltr}[IND_UPPER_LIMIT]))
##
##
##		{
##		}
##	if(  $foc_pos_from_file ge $filter_focus_properties{$fltr}[IND_FOC_DEF]) && 
	if(( $fltr_from_file=~ m/$fltr/)&&( $foc_pos_from_file ne ""))
	{
	    $number_of_fits_files++ ;
	    $fits_files{$fits_file}[IND_FILTER_FILE] = $fltr ;
	    $fits_files{$fits_file}[IND_FOC_POS_FILE]= $foc_pos_from_file ;
	    $fits_files{$fits_file}[IND_BINNING_FILE]= $binning_from_file ;
	    $fits_files{$fits_file}[IND_NAXIS1_FILE] = $naxis1_from_file ;
	    $fits_files{$fits_file}[IND_NAXIS2_FILE] = $naxis2_from_file ;
	    $fits_files{$fits_file}[IND_ORIRA_FILE]  = $orira_from_file ;
	    $fits_files{$fits_file}[IND_ORIDEC_FILE] = $oridec_from_file ;
	    $number_of_images_at_foc_pos{$foc_pos_from_file}++ ;
	}
    }
    if( $verbose== TRUE)
    {
	foreach my $foc_pos( sort keys %number_of_images_at_foc_pos)
	{
	    printf( "get_fits_files: filter $fltr, at foc_pos $foc_pos: %4d image%s", $number_of_images_at_foc_pos{ $foc_pos}, ($number_of_images_at_foc_pos{ $foc_pos}==1)? "": "s") ;
	}
    }
    my $noff= TOO_FEW_FITS_FILES ;
    if( $number_of_fits_files< $noff)
    {
	foreach my $fits_file ( sort by_foc_pos keys %fits_files)
	{
	    print "get_fits_files: FILE $fits_file, $fits_files{$fits_file}[IND_FILTER_FILE], $fits_files{$fits_file}[IND_FOC_POS_FILE]\n" ;
	}
	print "in $directory" ;
	if( $number_of_fits_files> 0)
	{
	    print " only $number_of_fits_files" ;
	}
	else
	{
	    print " no" ;
	}
	print " fits files found matching filter $fltr, required are $noff (TOO_FEW_FITS_FILES), returning\n" ;
	return FALSE ;
    }
# stop if something is wrong, simple approach
    my @fits_file_keys= keys %fits_files ;
    foreach my $fits_file ( keys %fits_files)
    {
	if( $fits_files{$fits_file_keys[0]}[IND_BINNING_FILE] ne $fits_files{$fits_file}[IND_BINNING_FILE])
	{
	    print "get_fits_files: binning $fits_files{$fits_file_keys[0]}[IND_BINNING_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_BINNING_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_NAXIS1_FILE] ne $fits_files{$fits_file}[IND_NAXIS1_FILE])
	{
	    print "get_fits_files: naxis1 $fits_files{$fits_file_keys[0]}[IND_NAXIS1_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_NAXIS1_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_NAXIS2_FILE] ne $fits_files{$fits_file}[IND_NAXIS2_FILE])
	{
	    print "get_fits_files: naxis2 $fits_files{$fits_file_keys[0]}[IND_NAXIS2_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_NAXIS2_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_ORIRA_FILE] ne $fits_files{$fits_file}[IND_ORIRA_FILE])
	{
	    print "get_fits_files: orira $fits_files{$fits_file_keys[0]}[IND_ORIRA_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_ORIRA_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
	elsif( $fits_files{$fits_file_keys[0]}[IND_ORIDEC_FILE] ne $fits_files{$fits_file}[IND_ORIDEC_FILE])
	{
	    print "get_fits_files: oridec $fits_files{$fits_file_keys[0]}[IND_ORIDEC_FILE] in $fits_file_keys[0] does differ from $fits_files{$fits_file}[IND_ORIDEC_FILE] in $fits_file, exiting\n" ;
	    exit 1 ;
	}
    }
    return TRUE ;
}
sub get_fitted_focus
{
    my $fltr           = shift @_ ;
    my $fits_dir       = shift @_ ;
    my $cfg            = shift @_ ;
    my $param          = shift @_ ;
    my $reference_param   = shift @_ ;
    my $sky_list          = shift @_ ;
    my $cat               = shift @_ ;
    my $fitprg            = shift @_ ; 
    my $fit_result_file   = shift @_ ;
    my $ds9_region_file   = shift @_ ;
    my $set_limits_on_sanity_checks = shift @_ ;
    my $find_rough_focus  = shift @_ ;

    my $ret_get_fits= FALSE ;
    my $ret_create  = FALSE ;
    my $ret_ret     = FALSE ;
    my $ret_fit     = FALSE ;
    my $fit_focus   = FALSE ;
    my %data_points;
    my @fwhm_data_file_names ;
    my @flux_data_file_names ;
    my @mean_focus=(FALSE,FALSE) ;
    my $date= "" ;

    my $date_reference= `date --iso-8601=seconds --utc` ;
    chomp $date_reference ;
   
    $ret_create= create_reference_catalogue( $fltr, $cfg, $param, $reference_param, $sky_list, $date_reference, $find_rough_focus) ;

    if( $ret_create== TRUE)
    {
	$date= $date_reference ;
	$ret_ret= retrieve_data( $fltr, $cfg, $param, $reference_param, $sky_list, $cat, $date, $date_reference, $ds9_region_file, \%data_points) ;

#ToDo: check the spatial distribution and update the reference DS9 reg file
#      calculate the center of mass and compare it with the CCD dimensions from fits file (incl. binning)
#ToDo: make a selection on spatial distribution

	my @data_minimum         = (1e12,1e12) ;
	my @data_maximum         = (0,0) ;
	for( my $qty=0 ; $qty < 2; $qty++)
	{
	    my $foc_pos_minimum      = 1e12 ;
	    my $foc_pos_minimum_index= 0 ;

	    my $foc_pos_maximum      = 1e12 ;
	    my $foc_pos_maximum_index= 0 ;
# find extrema
	    my @focuser_positions ;
	    sub numeric { $a <=> $b ; } # surprise, that works!
	    foreach my $foc_pos ( sort numeric keys %data_points) # yes!
	    {
		push(@focuser_positions, $foc_pos) ;
		if( $data_points{$foc_pos}[$qty] < $data_minimum[$qty])
		{
		    $foc_pos_minimum= $foc_pos ;
		    $foc_pos_minimum_index++ ;
		    $data_minimum[$qty]= $data_points{$foc_pos}[$qty] ;
		}
		if( $data_points{$foc_pos}[$qty] > $data_maximum[$qty])
		{
		    $foc_pos_maximum= $foc_pos ;
		    $foc_pos_maximum_index++ ;
		    $data_maximum[$qty]= $data_points{$foc_pos}[$qty] ;
		}	
	    }
# check if the location of the extrema is symmetric in respect of foc_pos (ul-ll)/2 + ul from data
#
	    my $data_minimum_centered_to_data_limits= TRUE; 
	    my $limits_minimum_difference= FALSE ;
	    if ( abs($foc_pos_minimum- ($focuser_positions[$#focuser_positions]- $focuser_positions[0])/2 + $focuser_positions[0])> 3 * $focuser_properties{resolution})
	    {
		$data_minimum_centered_to_data_limits= FALSE ;
		print "get_fitted_focus: quantity: $qty, data minimum ($data_minimum[$qty]) is not centered, lower limit $focuser_positions[0], data minimum $foc_pos_minimum, upper limit $focuser_positions[$#focuser_positions]\n" ;
	    }
	    my $data_maximum_centered_to_data_limits= TRUE; 
	    my $limits_maximum_difference= FALSE ;
	    if ( abs($foc_pos_maximum- ($focuser_positions[$#focuser_positions]- $focuser_positions[0])/2 + $focuser_positions[0])> 3 * $focuser_properties{resolution})
	    {
		$data_maximum_centered_to_data_limits= FALSE ;
		print "get_fitted_focus: quantity: $qty, data maximum ($data_maximum[$qty]) is not centered, lower limit $focuser_positions[0], data maximum $foc_pos_maximum, upper limit $focuser_positions[$#focuser_positions]\n" ;
	    }
# find out if lower or upper limit is nearer to the minimum
#ToDo: abs() might not be a good idea, loosing information

	    my $lower_limit= $focuser_positions[0] ; 
	    my $upper_limit= $focuser_positions[$#focuser_positions] ;

	    my $cosmetics ; # make a nicer plot (y axis is for FWHM [px] and for FLUX_MAX [a.u.])
	    if( $qty==0) # ToDo ugly but quick, FWHM
	    {
		$cosmetics= $number_of_objects_found_in_all_files ; 
		if( abs($focuser_positions[$#focuser_positions]- $foc_pos_minimum) < abs($focuser_positions[0]- $foc_pos_minimum))
		{
# distance to upper limit is smaller than to lower limit, set symmetric value lower limit
		    $limits_minimum_difference= LOWER ;
		    if( $set_limits_on_sanity_checks== TRUE)
		    {
			$lower_limit= $foc_pos_minimum - abs($focuser_positions[$#focuser_positions]- $foc_pos_minimum) ;
		    }
		}
		else
		{
# distance to lower limit is smaller than to upper limit, set symmetric value upper limit
		    $limits_minimum_difference= UPPER ;
		    if( $set_limits_on_sanity_checks== TRUE)
		    {
			$upper_limit= $foc_pos_minimum + abs($focuser_positions[0]- $foc_pos_minimum) ;
		    }
		}
	    }
	    else # FLUX_MAX
	    {
		$cosmetics= $number_of_objects_found_in_all_files * $data_maximum[1] / $data_maximum[0]    ; #  
		if( abs($focuser_positions[$#focuser_positions]- $foc_pos_maximum) < abs($focuser_positions[0]- $foc_pos_maximum))
		{
# distance to upper limit is smaller than to lower limit, set symmetric value lower limit
		    $limits_minimum_difference= LOWER ;
		    if( $set_limits_on_sanity_checks== TRUE)
		    {
			$lower_limit= $foc_pos_maximum - abs($focuser_positions[$#focuser_positions]- $foc_pos_maximum) ;
		    }
		}
		else
		{
# distance to lower limit is smaller than to upper limit, set symmetric value upper limit
		    $limits_minimum_difference= UPPER ;
		    if( $set_limits_on_sanity_checks== TRUE)
		    {
			$upper_limit= $foc_pos_maximum + abs($focuser_positions[0]- $foc_pos_maximum) ;
		    }
		}
	    } 
	    print "get_fitted_focus: quantity: $qty, lower limit set to $lower_limit\n" ;
	    print "get_fitted_focus: quantity: $qty, upper limit set to $upper_limit\n" ;
# write the data files and store their names
	    if(( $fitprg eq FOCROOTI) ||($fitprg eq FOCROOTB))
	    {
		my $data_file_name= $fit_result_file ; # just a reminder
		my $file_name= write_data_files( $fltr, $date, $fitprg, $data_file_name, $lower_limit, $upper_limit, $cosmetics, $qty, $set_limits_on_sanity_checks, \%data_points)  ;
# store file name for fitting
		if( $qty== 0) # FWHM, FLUX_MAX
		{
		    push (@fwhm_data_file_names, $file_name) ;
		}
		else
		{
		    push (@flux_data_file_names, $file_name) ;
		}
	    }
	}
    }
# fit
    if( $#fwhm_data_file_names !=  $#flux_data_file_names )
    {
	printf( "get_fitted_focus: difference between number of fwhm and flux fits: %d != %d, returning\n", $#fwhm_data_file_names, $#flux_data_file_names) ;
	return FALSE ;
    }
    else
    {
	for( my $fn=0 ; $fn< $#fwhm_data_file_names+ 1; $fn++)
	{
	    @mean_focus= fit_and_read_results( $fltr, $date, $fitprg, $fit_result_file, $fwhm_data_file_names[$fn], $flux_data_file_names[$fn])
	}
    }
    if(($mean_focus[0] != FALSE)&&($mean_focus[1] != FALSE))
    {
	if(abs($mean_focus[0]- $mean_focus[1])  < $focuser_properties{"resolution"})
	{
	    print "get_fitted_focus: SUCCESS SUCCESS: $mean_focus[0]- $mean_focus[1] < $focuser_properties{\"resolution\"}\n" ;
	    return ($mean_focus[0]+ $mean_focus[1])/2. ;
	}
	else
	{
	    print "get_fitted_focus: NO SUCCESS $mean_focus[0]- $mean_focus[1] > $focuser_properties{\"resolution\"}\n" ;
	    printf ("get_fitted_focus: NO SUCCESS $mean_focus[0]- $mean_focus[1]= %f > $focuser_properties{\"resolution\"}\n", $mean_focus[0]- $mean_focus[1]) ;
	}
    }
    else
    {
	print "get_fitted_focus: NO SUCCESS $mean_focus[0], $mean_focus[1]\n" ;
    }
    return FALSE ;
}
sub write_data_files
{
    my $fltr           = shift @_ ; 
    my $date           = shift @_ ;
    my $fit_prg        = shift @_ ;
    my $fit_result_file= shift @_ ;
    my $lower_lmt      = shift @_ ;
    my $upper_lmt      = shift @_ ;
    my $cosmetics      = shift @_ ;
    my $qty            = shift @_ ;
    my $set_limits_on_sanity_checks = shift @_ ;
    my $number_of_lines= 0 ;

    my @fit_items= split(/\./, $fit_result_file) ;
    my $tmp_fit_file_name ;
    if( $qty==0)
    {
	$tmp_fit_file_name=  $fit_items[0]."-".$fltr."-".$date."-FWHM_IMAGE.".$fit_items[1];
    }
    else
    {
	$tmp_fit_file_name=  $fit_items[0]."-".$fltr."-".$date."-FLUX_MAX.".$fit_items[1];
    }
    open( DATA, ">$tmp_fit_file_name") or die "write_data_files: can't write to file: $tmp_fit_file_name, $!" ;

    foreach my $foc_pos ( sort keys %{$_[0]})
    {
 	if(($foc_pos>= $lower_lmt)&&($foc_pos<= $upper_lmt))
	{
	    printf( DATA "%04d    %e\n", $foc_pos, ${$_[0]}{$foc_pos}[$qty]/$cosmetics ) ; # ToDo: normalize 
	    $number_of_lines++ ;

	    if( $verbose==TRUE)
	    {
		printf(     "%04d    %7.5f\n", $foc_pos, ${$_[0]}{$foc_pos}[$qty]/$cosmetics ) ;
	    }
	}
	else
	{
	    if( $set_limits_on_sanity_checks== FALSE)
	    {
	  	printf(     "write_data_files: wrong limits?: ll=$lower_lmt ul=$upper_lmt, %04d    %7.5f\n", $foc_pos, ${$_[0]}{$foc_pos}[$qty]/$cosmetics ) ;  
	    }
	}
    }
    close(DATA) ;

    if( $number_of_lines < 10)
    {
	print "write_data_files: data for fitting, lines written: $number_of_lines\n" ;
    }
    return  $tmp_fit_file_name;
}
sub fit_and_read_results
{
    my $fltr      = shift @_ ;
    my $date      = shift @_ ; 
    my $fitprg    = shift @_ ;
    my $fit_result_file= shift @_ ;
    my $fwhm_file = shift @_ ;
    my $flux_file = shift @_ ;
    my $fwhm_focus= FALSE ;
    my $flux_focus= FALSE ;
    my $number_of_results= 0 ;
# both fits go into a TMultiGraph

    my @fit_items= split(/\./, $fit_result_file) ;
    my $tmp_fit_result_file=  $fit_items[0]."-".$fltr."-".$date.".png"; # if you don want png, choose something else http://root.cern.ch/root/html/TPad.html#TPad:SaveAs
# attention fitprg means fit_focus (0|1) !
    open( ROOT, "$fitprg $fltr $date $number_of_objects_found_in_all_files $fwhm_file $flux_file $tmp_fit_result_file|") or die "fit_and_read_results: can't open pipe to $fitprg: $!" ;

    while( my $line=<ROOT>)
    {
	if( $line=~ m/^FWHM_FOCUS ([0-9]+\.[0-9]+)/)
	{
	    print "fit_and_read_results: got fwhm $1\n" ;
	    $fwhm_focus= $1 ;
	    $number_of_results++ ;
	}
	elsif( $line=~ m/^FLUX_FOCUS ([0-9]+\.[0-9]+)/)
	{
	    print "fit_and_read_results: got flux $1\n" ;
	    $flux_focus= $1 ;
	    $number_of_results++ ;
	}
	last if($number_of_results==2) ; # continue even if the plots appear
    }

    close( ROOT) ;
    return $fwhm_focus, $flux_focus ;
}
sub analyse_catalogue
{
    my $catalogue_tmp= shift @_ ;

    my $number_of_objects= 0 ;
    open(CATALOGUE, "<$catalogue_tmp") or die "analyse_catalogue: can't read $catalogue_tmp: $!";
  NEXT_OBJECT: while( my $line= <CATALOGUE>)
  {
      next if( $line=~ m/^#/) ;
      $line=~ s/[ \t\r\n]+/ /g ;
      $line=~ s/^[ ]+//g ;
      my @items= split(/[ ]+/, $line) ;
# select the objects in a similar way like raw_analysis() 
      if( $items[FLAGS] != 0)    
      {
	  goto  NEXT_OBJECT;
      }
      if( $items[ELLIPTICITY]> .1)
      {
	  goto NEXT_OBJECT ;
      }
      $number_of_objects++ ;
  }
    close(CATALOGUE) ;
    return $number_of_objects ;
}
sub get_foc_pos_at_maximum_number_of_objects
{
    my $fltr                = shift @_ ;
    my $fits_dir            = shift @_ ;
    my $cfg                 = shift @_ ;
    my $param_reference     = shift @_ ;
    my $rename              = shift @_ ;

    my $maximum_objects= 0 ;

    my $rough_focus_run_extension= ROUGH_FOCUS_RUN_EXTENSION ;
    my $fits_file_max="" ;
    my $catalogue_tmp= SEX_TMP_CATALOGUE ;
    my $catalogue_tmp_max= $catalogue_tmp.".max" ;

    foreach my $fits_file ( sort by_foc_pos keys %fits_files)
    {
# define the objects
	open(SEXANALYSIS, SEXPRG." $fits_file -c $cfg -CATALOG_NAME $catalogue_tmp -PARAMETERS_NAME $param_reference|") or die "get_foc_pos_at_maximum_number_of_objects: can't start SExtractor: $!";
	while(<SEXANALYSIS>){}
	close(SEXANALYSIS) ;
# count them
# ToDo: make a parameter
	my $number_of_objects= analyse_catalogue( $catalogue_tmp) ;
	if( $maximum_objects< $number_of_objects)
	{
	    $maximum_objects= $number_of_objects ;
	    $fits_file_max= $fits_file ;	
	    if( ! defined rename( $catalogue_tmp, $catalogue_tmp_max))
	    {
		print "get_foc_pos_at_maximum_number_of_objects: could not rename $catalogue_tmp to $catalogue_tmp_max, exiting\n";
		exit 1 ;
	    }
	}
	if( $rename== TRUE)
	{
#TODO: check that
#	    if( ! defined rename( $fits_file, $fits_file.$rough_focus_run_extension))
#	    {
#		print "get_foc_pos_at_maximum_number_of_objects: could not rename $fits_file to $fits_file.$rough_focus_run_extension, exiting\n";
#		exit 1 ;
#	    }
	}
    }
    if( $maximum_objects> 0)
    {
	if( ! defined rename( $catalogue_tmp_max, $catalogue_tmp))
	{
	    print "get_foc_pos_at_maximum_number_of_objects: could not rename $catalogue_tmp_max to $catalogue_tmp, exiting\n";
	    exit 1 ;
	}
	else
	{
	    print "get_foc_pos_at_maximum_number_of_objects: renamed $catalogue_tmp_max to $catalogue_tmp, continuing\n";
	}
	print "get_foc_pos_at_maximum_number_of_objects: $fits_file_max, $catalogue_tmp rough focus found at $fits_files{$fits_file_max}[IND_FOC_POS_FILE], objects $maximum_objects (not associated)\n" ;
	print "get_foc_pos_at_maximum_number_of_objects: update temporarily %filter_focus_properties\n" ;
	$filter_focus_properties{$fltr}[IND_FOC_DEF]=$fits_files{$fits_file_max}[IND_FOC_POS_FILE];
	return $filter_focus_properties{$fltr}[IND_FOC_DEF] ;
    }
    else
    {
	print "get_foc_pos_at_maximum_number_of_objects: number of objects== 0, exiting\n" ;
	exit 1 ;
    }
    return FALSE ;
}
sub create_reference_catalogue
{
    my $fltr            = shift @_ ;
    my $cfg             = shift @_ ;
    my $param           = shift @_ ;
    my $reference_param = shift @_ ;
    my $sky_list        = shift @_ ;
    my $date            = shift @_ ;
    my $find_rough_focus= shift @_ ;

    my $catalogue_tmp= SEX_TMP_CATALOGUE ;
    my @lst_items= split(/\./, $sky_list) ;
    my $tmp_sky_list_file_name=  $lst_items[0]."-".$fltr."-".$date.".".$lst_items[1];

    if( $find_rough_focus != TRUE)
    {
# create the reference sky list
#
	my $fits_file_reference="" ;
	foreach my $fits_file ( sort by_foc_pos keys %fits_files)
	{
	    if( $fits_files{$fits_file}[IND_FOC_POS_FILE]== $filter_focus_properties{$fltr}[IND_FOC_DEF])
	    {
		$fits_file_reference= $fits_file ;
		print "create_reference_catalogue: exact match of default focus position $filter_focus_properties{$fltr}[IND_FOC_DEF] in file $fits_file_reference\n" ;
		last ;
	    }
	    elsif($fits_files{$fits_file}[IND_FOC_POS_FILE]> $filter_focus_properties{$fltr}[IND_FOC_DEF])
	    {
		$fits_file_reference= $fits_file ;
		print "create_reference_catalogue: no exact match of default focus position $filter_focus_properties{$fltr}[IND_FOC_DEF], taking file $fits_file_reference as reference at position $fits_files{$fits_file}[IND_FOC_POS_FILE]\n" ;
		last ;
	    }
	}
# write the catalogue
#
	print "create_reference_catalogue: >>$fits_file_reference<<, if empty error\n" ;
	open(SEXANALYSIS, SEXPRG." $fits_file_reference -c $cfg -CATALOG_NAME $tmp_sky_list_file_name -PARAMETERS_NAME $reference_param|") or die "Can't start SExtractor: $!";
	while(<SEXANALYSIS>){}
	close(SEXANALYSIS) ;
    }
    else
    {
	if( ! defined rename( $catalogue_tmp, $tmp_sky_list_file_name))
	{
	    print "create_reference_catalogue: could not rename $catalogue_tmp to $tmp_sky_list_file_name, exiting\n";
	    exit 1 ;
	}
	else
	{
	    print "create_reference_catalogue: renamed $catalogue_tmp to $tmp_sky_list_file_name\n";
	}
    }
#define the number of reference objects
#
    $number_of_reference_objects= analyse_catalogue( $tmp_sky_list_file_name) ;
    return TRUE ;
}
sub retrieve_data
{
    my $fltr           = shift @_ ;
    my $cfg            = shift @_ ;
    my $param          = shift @_ ;
    my $reference_param= shift @_ ;
    my $sky_list       = shift @_ ;
    my $cat            = shift @_ ; 
    my $date           = shift @_ ;
    my $date_reference = shift @_ ;
    my $ds9_region_file= shift @_ ;

    my @lst_items= split(/\./, $sky_list) ;
    my $tmp_sky_list_file_name=  $lst_items[0]."-".$fltr."-".$date_reference.".".$lst_items[1];
#
# Compare the results from file with reference catalogue
#
    my %sex_results ;
    my $region_radius= 10. ; # radius region circles
    foreach my $fits_file ( sort by_foc_pos keys %fits_files)
    {
#
# receive results from SExtractor
#
	my @cat_items= split(/\./, $cat) ;
	my $tmp_cat_file_name=  $cat_items[0]."-".$fltr."-".$date."-".$fits_files{$fits_file}[IND_FOC_POS_FILE].".".$cat_items[1];

	open(SEXANALYSIS, SEXPRG." $fits_file -c $cfg -CATALOG_NAME $tmp_cat_file_name -PARAMETERS_NAME $param -ASSOC_NAME $tmp_sky_list_file_name|") or die "retrieve_data: can't start SExtractor: $!";
	while(<SEXANALYSIS>){}
	close(SEXANALYSIS) ;
#
##	print "extracting from file $fits_file, with configuration -c $cfg -CATALOG_NAME $cat-$fits_files{$fits_file}[IND_FOC_POS_FILE] -PARAMETERS_NAME $param -ASSOC_NAME $tmp_sky_list_file_name\n" ;
#
# open the result file, ToDo not good at the moment
#
	open(SEXINPUT, "$tmp_cat_file_name") or die "retrieve_data: can't read $tmp_cat_file_name: $!" ;
#
# open the ds9 region file and write the header
	my @ds9_items= split(/\./, $ds9_region_file) ;
	my $tmp_ds9_file_name=  $ds9_items[0]."-".$fltr."-".$date."-".$fits_file."-".$fits_files{$fits_file}[IND_FOC_POS_FILE].".".$ds9_items[1];

	my $number_of_objects= 0 ;
	my $number_of_selected_objects= 0 ;
	my $reference_object_number ;
	my @event_scalers=(0, 0, 0, 0) ;
	while(my $line=<SEXINPUT>)
	{
	    next if( $line=~ m/^#/) ; 
	    $line=~ s/[ \t\r\n]+/ /g ;
	    $line=~ s/^[ ]+//g ;
	    my @items= split(/[ ]+/, $line) ;

	    $reference_object_number= $items[NUMBER_REF]; 
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]= FALSE ;
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE]= FALSE ;
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE]= FALSE ;
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]= FALSE ;
	    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]= FALSE ;
# select the good objects according to sextractor properties
#
	    my $ret= raw_analysis( @items) ; # select good objects
	    if( $ret== SELECTED)
	    {
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]= $fits_files{$fits_file}[IND_FOC_POS_FILE] ;
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE]= $items[X_IMAGE];
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE]= $items[Y_IMAGE];
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]= $items[FWHM_IMAGE] ; # this is the quantity to be fitted
		$sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]= $items[FLUX_MAX]   ; # this is the quantity to be fitted

		$number_of_selected_objects++ ;
	    }
# count the reason why they were selected/rejected
	    $event_scalers[ $ret]++ ;
	    $number_of_objects++ ;
	}
	close( SEXINPUT) ;
	if( $number_of_objects> 0)
	{
	    printf("retrieve_data: $fits_file: filter: %3s, focuser position: %5d ", $fltr, $fits_files{$fits_file}[IND_FOC_POS_FILE]) ;
	    print "scaler values: " ;
# sex.cfg is configured to write only MATCHED objects
	    for( my $reason=0; $reason < $#event_scalers+1; $reason++)
	    {
		printf("%5d%s", $event_scalers[$reason], ($reason < $#event_scalers )? ", ": ", ") ; # lazy
	    }
	    printf("(selected/reference objects): %6.3f\n", $number_of_selected_objects/$number_of_reference_objects) ;

	    if(( $number_of_selected_objects/$number_of_reference_objects) < SELECT_RATIO)
	    {
		foreach my $reference_object_number( keys %{$sex_results{$fits_file}})
		{
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]= FALSE ;
		    $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]= FALSE ;
		}
		$number_of_images_at_foc_pos{ $fits_files{$fits_file}[IND_FOC_POS_FILE]}-- ;
		$number_of_fits_files-- ;
		printf( "retrieve_data: $fits_file discarded due to  SELECT_RATIO %5.3f < %5.3f\n", $number_of_selected_objects/$number_of_reference_objects, SELECT_RATIO);
	    }
	    else
	    {
# write only regions for accepted images
		open(DS9REGION, ">$tmp_ds9_file_name") or die "retrieve_data: can't write $tmp_ds9_file_name: $!" ;
		printf( DS9REGION "# Region file format: DS9 version 4.0\n") ;
		printf( DS9REGION "# Filename: $fits_file\n") ;
		printf( DS9REGION "global color=yellow font=\"helvetica 10 normal\" select=1 highlite=1 edit=1 move=1 delete=1 include=1 fixed=0 source\n") ;
		printf( DS9REGION "image\n") ; # not physical
		foreach my $reference_object_number (sort keys %{$sex_results{$fits_file}})
		{
		    if($sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS] != FALSE )
		    {
			printf( DS9REGION "circle\(%f,%f,%f\)\n", $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE],$sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE], $region_radius) ;
		    }
		}
		close( DS9REGION) ;
		$region_radius +=1 ;
	    }

	}
	else
	{
	    print "retrieve_data: $fits_file: focuser position: $fits_files{$fits_file}[IND_FOC_POS_FILE], number of objects == 0\n" ;  
	    print "retrieve_data: possibly bad reference image chosen, define FIND_ROUGH_FOCUS=> TRUE\n" ;
	    exit 1 ;
	}
    } # end loop fits files
    print "\n" ;
# count the objects
#
    print "retrieve_data: Select objects which appeared in all files!\n" ;
    my %objects ;
    my %number_per_object ;
    foreach my $fits_file ( keys %sex_results)
    {
	foreach my $reference_object_number ( keys %{$sex_results{$fits_file}})
	{
	    if($sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS] != FALSE)
	    {
		$number_per_object{$reference_object_number}= 0 ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]= FALSE;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][0]= 0;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][1]= 0;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_X_IMAGE]= FALSE;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_Y_IMAGE]= FALSE;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_NUMBER_OF_OBJECTS]= 0;
	    }
	}
    }
    my $number_of_data_points= 0 ;
    foreach my $fits_file ( keys %sex_results)
    {
	foreach my $reference_object_number ( sort keys %{$sex_results{$fits_file}})
	{
	    if($sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS] != FALSE)
	    {
		$number_per_object{$reference_object_number}++ ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_NUMBER_OF_OBJECTS]++ ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS] = $sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][0]+= $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][1]+= $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_X_IMAGE] = $sex_results{$fits_file}{$reference_object_number}[IND_SEX_X_IMAGE] ;
		$objects{$reference_object_number}{$fits_file}[IND_OBJ_Y_IMAGE] = $sex_results{$fits_file}{$reference_object_number}[IND_SEX_Y_IMAGE] ;
		$number_of_data_points++ ;
	    }
	}
    }
    print "retrieve_data: number of fits files $number_of_fits_files, data points $number_of_data_points\n" ;
# define those objects which appeared in all files
# fit the obtained DATA values 
#
    my %objects_found_in_all_files ;
    foreach my $reference_object_number ( keys %objects)
    {
	if( $verbose== TRUE)
	{
	    printf( "retrieve_data: filter %3s, number per object %5s: %4d\n", $fltr, $reference_object_number, $number_per_object{$reference_object_number}) ;
	}
	foreach my $fits_file ( keys %{$objects{$reference_object_number}})
	{
	    if( $number_per_object{$reference_object_number}== $number_of_fits_files) # object must appear in all files
	    {
		# the fits file names appear still in the lists, so they are here neglected
		if( $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS] != FALSE)
		{
		    if( $number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]} >0)
		    {
# creating the data point,  
#                       %data_points
			${$_[0]}{$sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]}[0] += $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][0]/ $number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]}; # sum data
			${$_[0]}{$sex_results{$fits_file}{$reference_object_number}[IND_SEX_FOC_POS]}[1] += $sex_results{$fits_file}{$reference_object_number}[IND_SEX_DATA][1]/ $number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]}; # sum data
# book keeping:
			$objects_found_in_all_files{$reference_object_number}[0]++ ;
			$objects_found_in_all_files{$reference_object_number}[1]    = $objects{$reference_object_number}{$fits_file}[IND_OBJ_X_IMAGE] ;
			$objects_found_in_all_files{$reference_object_number}[2]    = $objects{$reference_object_number}{$fits_file}[IND_OBJ_Y_IMAGE] ;
			$objects_found_in_all_files{$reference_object_number}[3][0]+= $objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][0] ;
			$objects_found_in_all_files{$reference_object_number}[4][1]+= $objects{$reference_object_number}{$fits_file}[IND_OBJ_DATA][1] ;
		    }
		    else
		    {
			 printf "retrieve_data: $fits_file, foc_pos=$objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS], object $reference_object_number has number of images >>$number_of_images_at_foc_pos{ $objects{$reference_object_number}{$fits_file}[IND_OBJ_FOC_POS]}<<\n" ;
		    }
		}
		else
		{
		    print "retrieve_data: $fits_file, $reference_object_number has FOC_POS == FALSE\n" ;
		}
	    }
	    else
	    {
		if( $verbose== TRUE)
		{
		    printf( "retrieve_data: not included: filter %3s, number per object %5s: %4d from file %s\n", $fltr, $reference_object_number, $number_per_object{$reference_object_number}, $fits_file) ;
		}
	    }
	}
    }
#
# write ds9 region file
#
    my @ds9_items= split(/\./, $ds9_region_file) ;
    my $tmp_file_name=  $ds9_items[0]."-".$fltr."-".$date.".".$ds9_items[1];
    
    open(DS9REGION, ">$tmp_file_name") or die "Can't write $tmp_file_name: $!" ;
    printf( DS9REGION "# Region file format: DS9 version 4.0\n") ;
    printf( DS9REGION "# Filter: $fltr, $date\n") ;
    printf( DS9REGION "global color=green font=\"helvetica 10 normal\" select=1 highlite=1 edit=1 move=1 delete=1 include=1 fixed=0 source\n") ;
    printf( DS9REGION "physical\n") ;

    $number_of_objects_found_in_all_files= 0;
    foreach my $reference_object_number ( sort keys %objects_found_in_all_files)
    {
	$number_of_objects_found_in_all_files++ ;
# ToDo: calculate the center of mass and report location, 
	if( $verbose==TRUE)
	{
	    printf("object: %5d, found %3d, X=%7.2f,  Y=%7.2f, data: %10.2f\n", $reference_object_number, $objects_found_in_all_files{$reference_object_number}[0], $objects_found_in_all_files{$reference_object_number}[1], $objects_found_in_all_files{$reference_object_number}[2], $objects_found_in_all_files{$reference_object_number}[3]) ;
	}
	printf( DS9REGION "circle\(%f,%f,10.1\) # text = {%d}\n", $objects_found_in_all_files{$reference_object_number}[1], 
                                                  $objects_found_in_all_files{$reference_object_number}[2], $reference_object_number) ;

	if( $objects_found_in_all_files{$reference_object_number}[0] !=$number_of_fits_files)
	{
	    print "attention something is severely wrong here counts must be equal $objects_found_in_all_files{$reference_object_number}[0] !=$number_of_fits_files\n" ;
	}
    }
    close(DS9REGION) ;

    print "found $number_of_objects_found_in_all_files objects in all files\n" ;

    if( $number_of_objects_found_in_all_files < MINIMUM_OBJECTS)
    {
	print "to few objects matched in all files, exiting\n" ;
	exit 1 ;
    }
    return TRUE ;
}
# print help information
#------------------------------------------------------------------------------
sub print_usage
{
  print "usage: $scriptname [options]\n\n";
  print "  options:\n";
  print "    -h --help:      print this help information.\n";
  print "       --version:   print program version information.\n";
  print "    -v --verbose:   be verbose by printing progressing to stdout.\n";
}
#------------------------------------------------------------------------------
# main program
#------------------------------------------------------------------------------

my $help = 0;
my $version = 0;
$verbose = FALSE;
my $rts2_device_camd_default= CCD_CAMERA ;
my $rts2_device_camd= "" ;
my $rts2_device_filterd= "" ;
my $rts2_device_focusd= "" ;
my $rts2_device_camd_present= FALSE ;
my $rts2_device_filterd_present=FALSE ;
my $rts2_device_focusd_present=FALSE ;
my $rts2_device_camd_filterd= "" ;
my $rts2_device_camd_focusd= "" ;

my $fits_directory     = FITS_DIRECTORY;
my $set_focus          = SET_FOCUS; 
my $take_data          = TAKE_DATA;
my $rts2_device_file   = RTS2_DEVICES ;
my $find_rough_focus   = FIND_ROUGH_FOCUS ;
my $number_of_rough_focus_images= NUMBER_OF_ROUGH_FOCUS_IMAGES ;
my $sexcfg             = SEXCFG ;
my $sexparam           = SEXPARAM ;
my $sexreference_param = SEXREFERENCE_PARAM ;
my $sexsky_list        = SEXSKY_LIST ;
my $sexcat             = SEXCATALOGUE ;
my $fitprg             = FITPRG ;
my $fit_result_file    = FIT_RESULT_FILE ;
my $ds9_region_file    = DS9_REGION_FILE ;
my @filters            = split(/:/, FILTERS) ;
my $set_limits_on_sanity_checks= SET_LIMITS_ON_SANITY_CHECKS ;
my $include_rough_focus_run= INCLUDE_ROUGH_FOCUS_RUN ;
my $ccd_binning        = CCD_BINNING ;
#ToDo: initialise!
my @rts2_filterd_filters ;
my $fit_focus= FALSE ;

if (!GetOptions("help|h"            => \$help, 
                "version"           => \$version,
                "verbose|v+"        => \$verbose,
		"fits_directory|a=s"=> \$fits_directory,
		"set_focus|b=s"     => \$set_focus,
		"take_data|c=s"     => \$take_data,
		"rts2-devices|e=s"  => \$rts2_device_file,
		"ccd|f=s"           => \$rts2_device_camd_default,
		"sexcfg|g=s"        => \$sexcfg,
		"sexparam|i=s"      => \$sexparam,
		"sexcat|j=s"        => \$sexcat,
		"fit_fwhm_program|k=s"=> \$fitprg,
		"find_rough_focus|m=i"=> \$find_rough_focus,
		"number_of_rough_focus_images|n=i"=> \$number_of_rough_focus_images,
		"include_rough_focus_run|o=i"     => \$include_rough_focus_run,
		"ccd_binning|p=i"     => \$ccd_binning,
               ))
# ToDo: what is that?
{
  print_usage();
  print "No arguments given, taking defaults\n" ;
}

if ($help) {
  print_usage();
  exit 0;
} elsif ($version) {
  print "$scriptname rev. $cvs_revision, $cvs_date\n";
  exit 0;
}
if(( $set_focus== TRUE) && ($#filters>0))
{
    print "$scriptname: can not set focus while $#filters should be measured, select a single filter\n" ;
    print_usage();
    exit 1 ;
}
# check presence of the config files, devices, *.cfg, *.param, and the reference *.param
#
unless ( -e $rts2_device_file)
{
    print "$scriptname: not found $rts2_device_file\n" ;
    exit 1;
}
unless ( -e $sexcfg)
{
    print "$scriptname: not found $sexcfg\n" ;
    exit 1;
}
unless ( -e $sexparam)
{
    print "$scriptname: not found $sexparam\n" ;
    exit 1;
}
unless ( -e $sexreference_param)
{
    print "$scriptname: not found $sexreference_param\n" ;
    exit 1;
}
#
# open RTS2 device file, read device names and extract the filters from wheel
# works with several ccd, fw, fc devices, e.g.:
##RTS2 devices configuration
##device type    device_name     options
#filterd  fli    FW     -F "U:B:V:R:I:X:Y" --fli_debug 1
#focusd   fli    FC
#camd     fli    CD     -F FC -W FW -r -23.6 -l 5 -c 0.
#filterd  fli    FR     -F "U:B:V:R:I:X:Y" --fli_debug 1
#focusd   fli    FR
#camd     fli    CR     -F FR -W FR -r -23.6 -l 5 -c 0.
#
# fetch first the ccd
#
open( DEVICES, $rts2_device_file) or die "$scriptname: can't open $rts2_device_file: $!" ;
while(my $line=<DEVICES>)
{
    if( $line=~ m/^[ \t]*camd[ \t]+(\w+)[ \t]+(\w+)[ \t]+(.*)/)
    {
	if( $2 eq $rts2_device_camd_default)
	{
	    $rts2_device_camd= $2 ;
	    $rts2_device_camd_present= TRUE ;

	    my $arguments= $3 ;
	    if( $arguments=~ m/(--focdev|-F)[ \t]+([\w]+)/)
	    {
		$rts2_device_camd_focusd= $2 ;
	    }
	    if( $arguments=~ m/(--wheeldev|-W)[ \t]+([\w]+)/)
	    {
		$rts2_device_camd_filterd= $2 ;
	    }
	}
    }
}
close(DEVICES) ;
# then associated filter and focuser devices
#
open( DEVICES, $rts2_device_file) or die "$scriptname: can't open $rts2_device_file: $!" ;
while(my $line=<DEVICES>)
{
    if($line=~ m/^[ \t]*filterd[ \t]+(\w+)[ \t]+($rts2_device_camd_filterd)[ \t]+(.*)/)
    {
	$rts2_device_filterd= $2 ;
	$rts2_device_filterd_present= TRUE ;
	my $arguments= $3 ;
# filter names, separated 
	if( $arguments=~ m/\-F[ \t]+"([\w:]+)"/)
	{
	    my $string= $1 ;
	    @rts2_filterd_filters=split( /[ :]/, $string) ;
	}
    }
    elsif($line=~ m/^[ \t]*focusd[ \t]+(\w+)[ \t]+($rts2_device_camd_focusd)[ \t]+(.*)/)
    {
	$rts2_device_focusd= $2 ;
	$rts2_device_focusd_present= TRUE ;
    }
}
close(DEVICES) ;
# change to the working directory ev. write and get the list of fits files
#
chdir $fits_directory or die "$scriptname: can not change to directory $fits_directory: $!" ;
#
# offline analysis, data taking
#
if( $take_data== FALSE) # offline analysis
{
    foreach my $filter (@filters)
    {
	my $ret_get_fits= get_fits_files( $filter, $fits_directory, $include_rough_focus_run) ;
	if( $ret_get_fits== TRUE)
	{
	    my $foc_pos_maximum_objects= FALSE ;
	    if( $find_rough_focus== TRUE)
	    {
		if(( $foc_pos_maximum_objects=get_foc_pos_at_maximum_number_of_objects($filter, $fits_directory, $sexcfg, $sexreference_param, FALSE)) != FALSE ) 
		{
		    $fit_focus= get_fitted_focus( $filter, $fits_directory, $sexcfg, $sexparam, $sexreference_param, $sexsky_list, $sexcat, $fitprg, $fit_result_file, $ds9_region_file, $set_limits_on_sanity_checks, $find_rough_focus) ;
		}
		else
		{
		    print "$scriptname: no rough focus found, exiting\n" ;
		    exit 1 ;
		}
	    }
	    else
	    {
		$fit_focus= get_fitted_focus( $filter, $fits_directory, $sexcfg, $sexparam, $sexreference_param, $sexsky_list, $sexcat, $fitprg, $fit_result_file, $ds9_region_file, $set_limits_on_sanity_checks, $find_rough_focus) ;	
	    }
	}
	undef %fits_files ;
    }
}
elsif( $take_data== TRUE) # online analysis
{
# Perform consistency checks
#
    if( $rts2_device_camd ne $rts2_device_camd_default)
    {
	print "$scriptname: ccd devices $rts2_device_camd_default not present, can not take data\n" ;
	exit 1 ;
    }
    if(!(($rts2_device_camd_present== TRUE ) &&($rts2_device_filterd_present== TRUE) &&($rts2_device_focusd_present== TRUE)))
    {
	print "$scriptname: not all devices present,  can not take data\n" ;
	exit 1 ;
    }
# Compare the to camd related devices with the arguments
#
    if(!(($rts2_device_camd_focusd eq $rts2_device_focusd) && ( $rts2_device_camd_filterd eq $rts2_device_filterd)))
    {
	print "$scriptname: device mismatch, can not take data $rts2_device_camd_focusd eq $rts2_device_focusd, $rts2_device_camd_filterd eq $rts2_device_filterd\n" ;
	exit 1 ;
    }
# Compare the to filterd related filters with the arguments
#
    my $found= 0 ;
    foreach my $filter (@filters)
    {
	foreach my $rts2_filterd_filter (@rts2_filterd_filters)
	{
	    if ( $filter eq $rts2_filterd_filter)
	    {
		$found++ ;
		last ;
	    }
	}
    }
    if( $found!= $#filters+1)
    {
	print "$scriptname: not all filters present, can not take data $found!= $#filters+1 (see e.g. FILTERS)\n" ;
        print "$scriptname: filters present: " ;
	foreach my $filter (  @filters)
	{
	    printf( "$filter ") ;
	}
	printf( "\n") ;
        exit 1 ;
    }
    printf( "$scriptname: data taking with devices: %s, %s, %s and ", $rts2_device_focusd, $rts2_device_filterd, $rts2_device_camd) ;
    foreach my $filter (  @filters)
    {
	printf( "$filter ") ;
    }
    printf( "\n") ;
# ok everything is present, take data
    foreach my $filter ( @filters)
    {
	my $number_steps= 0 ;
	if( $filter_focus_properties{$filter}[IND_STEP_SIZE] > 0)
	{
	    $number_steps= ($filter_focus_properties{$filter}[IND_UPPER_LIMIT] - $filter_focus_properties{$filter}[IND_LOWER_LIMIT]) / $filter_focus_properties{$filter}[IND_STEP_SIZE] ;
	    $number_steps=~ s/\.[0-9]+$// ; # truncate
	}
	else
	{
	    print "$scriptname: define a sensible step size for filter $filter, values: $filter_focus_properties{$filter}[IND_LOWER_LIMIT], $filter_focus_properties{$filter}[IND_UPPER_LIMIT], $filter_focus_properties{$filter}[IND_STEP_SIZE]\n" ;
	    exit 1 ;
	}
# set and get filter
	set_rts2_filter($rts2_device_filterd, $filter) ;
	get_rts2_filter($rts2_device_filterd, $filter) ; 
# find rough focus
	if( $find_rough_focus== TRUE)
	{
# script
#
# set FOC_DEF    = ABSOUTE_UPPER_LIMIT- ABSOUTE_LOWER_LIMIT
# set FC.FOC_TOFF=  $focus_properties[ABSOUTE_LOWER_LIMIT]
# take NUMBER_OF_ROUGH_FOCUS_IMAGES images
# step_size      = (ABSOUTE_UPPER_LIMIT- ABSOUTE_LOWER_LIMIT)/NUMBER_OF_ROUGH_FOCUS_IMAGES
#
# e.g. rts2-scriptexec -d CD -s ' CD.binning=1 FC.FOC_TOFF=lower_limit for number_steps { E exp_time_filter FC.FOC_TOFF+=step_size } '
#
	    my $number_steps= 0 ;
	    $number_steps   = $number_of_rough_focus_images;
	    $number_steps   =~ s/\.[0-9]+$// ; # truncate
	    my $size_step   =  ($focuser_properties{"absolute_upper_limit"}- $focuser_properties{"absolute_lower_limit"}) / $number_of_rough_focus_images ;
	    $size_step      =~ s/\.[0-9]+$// ; # truncate
# set FOC_DEF
#	    ul + middle = FOC_TOF ? wie muss das genau gemacht werden?
	    my $middle= ($focuser_properties{"absolute_upper_limit"}- $focuser_properties{"absolute_lower_limit"}) / 2 ;
	    $middle=~ s/\.[0-9]+$// ; # truncate

	    if( (NUMBER_OF_ROUGH_FOCUS_IMAGES * $size_step)> $focuser_properties{"absolute_upper_limit"})
	    {
		print "$scriptname: the calculation of step size is wrong, exiting\n" ;
		exit 1 ;
	    }
	    set_rts2_focus_default_position( $rts2_device_focusd, $middle) ;
#ToDo: issue a warning and exit if the FITS_DIRECTORY is not empty
	    print "$scriptname: rts2-scriptexec -d $rts2_device_camd -s ' $rts2_device_camd.binning=$ccd_binning $rts2_device_focusd.FOC_TOFF=-$middle for $number_steps { E $filter_focus_properties{$filter}[IND_EXP_TIME] $rts2_device_focusd.FOC_TOFF+=$size_step }\n" ;
 

	    open( FIND_ROUGH_FOCUS, "rts2-scriptexec -d $rts2_device_camd -s ' $rts2_device_camd.binning=$ccd_binning $rts2_device_focusd.FOC_TOFF=-$middle for $number_steps { E $filter_focus_properties{$filter}[IND_EXP_TIME] $rts2_device_focusd.FOC_TOFF+=$size_step } '|") or die "Can't rts2-exec: $!" ;
	    while( my $response= <FIND_ROUGH_FOCUS>)
	    {
		print "$scriptname: rough focus:$response" ;
	    }
	    close(FIND_ROUGH_FOCUS) ;

	    my $ret_get_fits= get_fits_files( $filter, $fits_directory, $include_rough_focus_run) ;
	    if( $ret_get_fits== TRUE)
	    {
		if(( my $foc_pos_maximum_objects=get_foc_pos_at_maximum_number_of_objects($filter, $fits_directory, $sexcfg, $sexreference_param, TRUE)) != FALSE ) 
		{
		    print "$scriptname: reference for rough focus created\n" ;
		}
		else
		{
		    print "$scriptname: undefined focus position, no maximum of objects found during rough focus analysis, exiting\n" ;
		    exit 1 ;
		}
	    }
	    else
	    {
		print "$scriptname: no fits files found during rough focus analysis\n" ;
	    }
	    undef %fits_files ;
	}
# set and get FOC_DEF
	set_rts2_focus_default_position( $rts2_device_focusd, $filter_focus_properties{$filter}[IND_FOC_DEF]) ;
## NO	get_rts2_focus( $rts2_device_focusd, $filter_focus_properties{$filter}[IND_FOC_DEF]) ;

# start main script
# This is the rts2 script
# e.g. rts2-scriptexec -d CD -s ' CD.binning=1 FC.FOC_TOFF=lower_limit for number_steps { E exp_time_filter FC.FOC_TOFF+=step_size } '
# 
# After rts2-scriptexec returns, all files are in the working directory
#
	print "$scriptname: rts2-scriptexec -d $rts2_device_camd -s '  $rts2_device_camd.binning=$ccd_binning $rts2_device_focusd.FOC_TOFF=$filter_focus_properties{$filter}[IND_LOWER_LIMIT] for $number_steps { E $filter_focus_properties{$filter}[IND_EXP_TIME] $rts2_device_focusd.FOC_TOFF+=$filter_focus_properties{$filter}[IND_STEP_SIZE] } '\n" ;
	open( CREATEFITS, "rts2-scriptexec -d $rts2_device_camd -s ' $rts2_device_camd.binning=$ccd_binning $rts2_device_focusd.FOC_TOFF=$filter_focus_properties{$filter}[IND_LOWER_LIMIT] for $number_steps { E $filter_focus_properties{$filter}[IND_EXP_TIME] $rts2_device_focusd.FOC_TOFF+=$filter_focus_properties{$filter}[IND_STEP_SIZE] } '|") or die "Can't rts2-exec: $!" ;
	while( my $response= <CREATEFITS>)
	{
	    print "$scriptname:$response" ;
	}
	close( CREATEFITS) ;
	my $ret_get_fits= get_fits_files( $filter, $fits_directory, $include_rough_focus_run) ; # took a while
	if( $ret_get_fits== TRUE)
	{
	    $fit_focus= get_fitted_focus( $filter, $fits_directory, $sexcfg, $sexparam, $sexreference_param, $sexsky_list, $sexcat, $fitprg, $fit_result_file, $ds9_region_file, $set_limits_on_sanity_checks, $find_rough_focus) ;
	}
	undef %fits_files ;
    }
}
else
{
    print "$scriptname: neither data taking nor offline analysis specified, exiting\n" ;
    exit 1 ;
}
#
# set the focus (only possible when only one filter has been chosen)
#
if( $set_focus== TRUE)
{
    if( $fit_focus != FALSE)
    {
	set_rts2_fit_focus_position($rts2_device_focusd, $fit_focus)
    }
    else
    {
	print "$scriptname: not setting undefined focus position\n" ;
    }
}
exit 0 ;
