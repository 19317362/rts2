\documentclass[a4paper]{article}
\usepackage{graphics}
\usepackage{czech}
\usepackage{courier}
\makeindex

\begin{document}

\include{macros}

\title{RTS2}

\author{Petr Kubánek, petr@lascaux.asu.cas.cz}

\maketitle

\section{Why RTS2?}

Based on my experience with the software, which drives observations at BART
telescope, I'm developing completely new code. It tries to attack RTS1
bottlenecks:

\begin{itemize}

\item{modularity} - RTS1 is complex beast, which made it quite difficult to
add new features (including new devices drivers) and find errors. RTS2 is
designed keeping modularity in mind.

\item{killing time} - at RTS1 we have to wait for exposure end or end of
telescope move before moving to new target (so we could wait for minutes
before starting to move to GRB error box).

\item{pointing} - it's almost imposible to add pointing, RTS2 is so designed
that it shoudl be relative easy.

\item{design} - RTS2 should be far more throughly designed then RTS1, because
of the lessons learned on RTS1.

\item{gui} - RTS1 lack ability to perform as server for observer willing to
observe with telescope. This will be easily possible at RTS2, which adds an
gui on top of server to provide handsome interface for manual observations.

\item{run-time error detection} - the main bottleneck of Python language. RTS1
detect most errors, even trivial syntax problem at runtime. We definitly need
some more strict language.

\item{standartization} - RTS1 use wide range of programming methods, RTS2 is
designed to use one common libraries for specifics tasks.

\item{versioning} - RTS2 is from early beginnings versioned in CVS. That
improves chances to quickly track newly emerging errors.

\item{security} - RTS2 uses common login name/password authentification.
RTS2 is also more secure by design.

\end{itemize}

\section{Architecture}

RTS 2 is designed with kind-of Object Oriented (OO) approach, but it
didn't use object programming language. It use design features to
simulate classes behaviour.

It consists of servers and clients build up on common supporting
libraries. Servers always wait for connections from clients.

The whole system, as could be deduced from figures below, uses agent-like
methology to deal with complex tasks. Every agent (or, better say, server)
offers specific functionality. Server is commanded by network protocol - use
of network allow mass scale distribution.

Whole system have following main parts:

\begin{itemize}

\item{serverd} - central point to handle device registration, user
login and priority changes.

\item{device daemon} - provides acces to devices.

\item{helpers} - coordinating complex tasks requiring more devices,
such as pointing.

\item{clients} - things directed observation. They receive from serverd
device listing, initiates connections to devices, and issued commands
to devides. Clients could be driven by script or by human observer
sitting in front of networked computer.

\end{itemize}

\dia{client-server-use1}{Simple client-server use}

\dia{client-server-use3}{Idea of pointing functionality}

\dia{client-server-use2}{Compelex example of architecture}

\section{Priority}

RTS2 uses priority mechanism to control which client will control
devices. Priority is changed throught serverd - that  atomicity.

Only client with highest priority could execute functions that change device
state, such as move of the telescope mount or exposure of the ccd chip.

Change of priority from one client to other could happen in two basic
modes - one is imediate priority change, which comes handy during post
GRB observations, second is deffered priority change, which comes
handy during sky patrol observations.

\section{Protocol}

Protocol is based on TELNET, as described in RFC 854.

Client send to server text commands. Server respons with status informations,
messages, and special request (e.g. request to initiate data transfer). 

To get better idea of the protocol, here is an example. Note that all
entries are in real protocol separated with CRLF.

\begin{tabular}{llp{6cm}}
client & server & explanation \\
\hline
auth 0 12345 & & sends authentification string \\
& +000 OK & authentification accepted \\
& M priority received & we now have priority \\
expose IMG 42 & & ask server to expose imaging chip with 42 seconds exposure
\\
& temperature -12.0 & some information about camera state \\
& setpoint -12.1 & some other info \\
& M img 12 start exposure & message that exposure was
started \\
& +000 OK & command have been sucessfully processed, it could run on server
as thread (that particular one does it so)  \\
& M img 15 exposure finished & do we need to say more? \\
readout IMG & & start readout of data from the chip \\
& D 1.2.3.4:10 12345 & initiates data transfer, at that point client have 
to create data connection to server \\
& readout from 4.3.2.1:76 started & some information \\
& M img 14 readout started & now start flood of data \\
& +000 OK & readout command ends here \\
& M img 17 readout aborted & what's that? \\
& M priority lost & ok, seems somebody else have more important task then
we.. \\
expose IMG 24 & & what happens when I~don't have priority? \\
& -007 no priority & I~was
expecting that \\
\end{tabular}

\vspace{1cm}

Here is textual description of protocol blocks:

\begin{itemize}

\item{commands} - sended from client, parameters separated with blanks.

\item{responses} - have format similar to commands, could occur only between
receiving command and response end.

\item{response end} - marked with + or - sign, gives textual explanation of
what's going on.

\item{special requests} - data transfer, .. - the common client library
understands that requests.

\item{messages} - starts with M, indicate change of software state. Messages
can appear anytime during communication. They are handled by special client
routine.

\end{itemize}

\section{List of commands}

Following commands are fully or partly implemented in actual code of
RTS2.

Please note that protocol is now evolving. It will settle during RTS2
operations test, expected at early 2003.

\subsection{Serverd}

\begin{description}

\item{login}  - authentification

\item{password} - authentification

\item{key} - authorization key

\item{register} - register new device

\item{priority} - set priority

\item{prioritydeferred} - set priority with waiting for priority block
end

\item{info} - print info about serverd

\end{description}

\subsection{Devdem}

\begin{description}

\item{auth} - authorization

\item{ready} - is device ready?

\item{help} - commands help

\item{exit} - close connection with server

\item{blockstart} - start observation block; used with
prioritydeferred priority change

\item{blockcheck} - enables prioritydeferred commands to take away
priority

\item{blockend} - end of observation block

\end{description}

\subsection{Camera}

\begin{description}

\item{chipinfo (chip)} - info about particular chip

\item{expose (chip) (exposure\_time)} - expose given seconds image on given chip

\item{stopexpo (chip)} - stop image exposure

\item{progexpo (chip)} - progress of image exposure

\item{binning (chip) (vbin) (hbin)} - change cammera binning

\item{readout (chip)} - readout camera chip

\item{stopread (chip)} - stop reading of data

\item{progread (chip)} - progress of data readout

\item{cooltemp (chip) (temperature)} - set temperature setpoint

\item{coolpower (chip) (temperature)} - set temperature power

\end{description}

\subsection{Mount}

\begin{description}

\item{set} - init location of mount

\item{move} - mount to new position

\item{ra} - get actual RA

\item{dec} - get actual DEC

\item{park} - park mount

\item{lon} - get mount longtitude

\item{lat} - get mount latitude

\item{lst} - get mount local sidereal time

\item{loct} - get local time

\end{description}

\subsection{Debug}

\begin{description}

\item{devserinfo} - serverd info

\item{devdeminfo} - device info

\end{description}

\section{Targets}

fast observations task switching - within 5 seconds, main delays should be
located at driver code, not at driving software

\end{document}
