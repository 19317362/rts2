// based on autogenerated Thrift skeleton

#include <pthread.h>
#include "device.h"
#include <libnova/libnova.h>

#include "MountService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::rts2;

// RTS2 thrift service..
class ThriftD: public rts2core::Device
{
	public:
		ThriftD (int argc, char **argv);
		virtual int idle ();

		MountInfo mountInfo;

	protected:
		virtual int willConnect (rts2core::NetworkAddress * _addr);
};

ThriftD::ThriftD (int argc, char **argv): rts2core::Device (argc, argv, DEVICE_TYPE_THRIFT, "THRIFT")
{
}

int ThriftD::idle ()
{
	rts2core::Connection *telConn = getOpenConnection (DEVICE_TYPE_MOUNT);
	if (telConn != NULL)
	{
		rts2core::Value *val;
		rts2core::ValueRaDec *raDec;
		rts2core::ValueAltAz *altAz;

		val = telConn->getValue ("infotime");
		if (val != NULL)
		{
			mountInfo.infotime = val->getValueDouble ();
		}
		raDec = (rts2core::ValueRaDec *) telConn->getValue ("ORI");
		if (raDec != NULL)
		{
			mountInfo.ORI.ra = raDec->getRa ();
			mountInfo.ORI.dec = raDec->getDec ();
		}
		raDec = (rts2core::ValueRaDec *) telConn->getValue ("OFFS");
		if (raDec != NULL)
		{
			mountInfo.offsets.ra = raDec->getRa ();
			mountInfo.offsets.dec = raDec->getDec ();
		}
		raDec = (rts2core::ValueRaDec *) telConn->getValue ("TEL");
		if (raDec != NULL)
		{
			mountInfo.TEL.ra = raDec->getRa ();
			mountInfo.TEL.dec = raDec->getDec ();
		}
		altAz = (rts2core::ValueAltAz *) telConn->getValue ("TEL_");
		if (altAz != NULL)
		{
			mountInfo.HRZ.alt = altAz->getAlt ();
			mountInfo.HRZ.az = ln_range_degrees (altAz->getAz () + 180.0);
		}
		val = telConn->getValue ("JD");
		if (val != NULL)
		{
			mountInfo.JulianDay = val->getValueDouble ();
		}


	}
	return Device::idle ();
}

int ThriftD::willConnect (rts2core::NetworkAddress *_addr)
{
	if (_addr->getType () < getDeviceType () || (_addr->getType () == getDeviceType () && strcmp (_addr->getName (), getDeviceName ()) < 0))
		return 1;
	return 0;
}

ThriftD *rts2Device;

void *rts2_thread (void *args)
{
	rts2Device->run ();
	return NULL;
}

class MountServiceHandler : virtual public MountServiceIf {
	public:
		MountServiceHandler() {
		}

		void info(MountInfo& _return) {
			_return = rts2Device->mountInfo;
		}

		int32_t Slew(const RaDec& target) {
			rts2core::CommandMove cmd (rts2Device, NULL, target.ra, target.dec);
			rts2Device->queueCommandForType (DEVICE_TYPE_MOUNT, cmd);
			return 0;
		}
};

void *thrift_thread (void *args)
{
		int port = 9093;
		shared_ptr<MountServiceHandler> handler(new MountServiceHandler());
		shared_ptr<TProcessor> processor(new MountServiceProcessor(handler));
		shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
		shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
		shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

		TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
		server.serve();
		return NULL;
}

int main (int argc, char **argv)
{
		rts2Device = new ThriftD (argc, argv);
 
		pthread_t thrift_thr;
		pthread_t rts2_thr;

		pthread_create (&rts2_thr, NULL, &rts2_thread, NULL);
		pthread_create (&thrift_thr, NULL, &thrift_thread, NULL);

		pthread_join (thrift_thr, NULL);
		pthread_join (rts2_thr, NULL);
		return 0;
}
